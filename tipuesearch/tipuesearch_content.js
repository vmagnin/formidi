var tipuesearch = {"pages":[{"title":" ForMIDI ","text":"ForMIDI A small Fortran MIDI sequencer for composing music, exploring algorithmic music and music theory. It can also be used to teach Fortran programming in a fun way. MIDI notes are numbers. You can therefore make music with prime numbers, mathematical suites (Fibonacci, Syracuse...), the decimals of Pi, etc. Like Bach and Shostakovich, you can also use letters from your name to create your own musical cryptogram , like BACH and DEsCH. Features Creates multi-tracks .mid files (MIDI 1.0). Includes some music theory elements (scales, circle of fifths, chords, notes values...) Includes routines for easily playing chords and broken chords. Includes the list of the General MIDI instruments and percussive instruments, and the list of the MIDI Control Changes. The API is documented with FORD: https://vmagnin.github.io/formidi/ Includes various examples with comments. You just need a modern Fortran compiler and a MIDI media player, whatever \nyour OS. GPL-3.0-or-later license. If you are interested by sound synthesis, you may also be interested by its twin project ForSynth . Compilation and execution You can easily build the project using the Fortran Package Manager fpm at the root of the project directory: $ fpm build Or you can use the build.sh script and run the build/*.out executable files. Running the examples The examples can be found in the example/ directory. For example, the canon.f90 example can be run with the command: $ fpm run --example canon The demos files are generated in the root directory of the project: $ file canon.mid\ncanon.mid: Standard MIDI data ( format 1 ) using 2 tracks at 1 /128 MIDI files are similar to music scores. They don't contain any sound but just binary coded commands for the instruments, and are therefore very light files: $ hexdump -C canon.mid 00000000 4d 54 68 64 00 00 00 06 00 01 00 05 00 80 4d 54 | MThd..........MT | 00000010 72 6b 00 00 00 1c 00 ff 02 0d 50 75 62 6c 69 63 | rk........Public | 00000020 20 64 6f 6d 61 69 6e 00 ff 51 03 0f 42 40 00 ff | domain..Q..B@.. | 00000030 2f 00 4d 54 72 6b 00 00 08 8a 00 ff 03 0b 67 72 | /.MTrk........gr | 00000040 6f 75 6e 64 20 62 61 73 73 00 b0 5b 40 00 c0 30 | ound bass.. [ @..0 | 00000050 00 90 32 40 81 00 80 32 00 00 90 2d 40 81 00 80 | ..2@...2...-@... | [ ... ] 00002329 The \"MThd\" string begins the header of the MIDI file. Each track begins with a header beginning by \"MTrk\". The first track is always a metadata track, containing for example the tempo of the music. Playing your MIDI file with a media player Linux TiMidity++ You can use TiMidity++ : $ timidity canon.mid The quality of the output depends essentially on the quality of the soundfont. By default, timidity uses the freepats soundfont. A better soundfont is FluidR3_GM.sf2 ( fluid-soundfont-gm package in Ubuntu): $ timidity canon.mid -x \"soundfont /usr/share/sounds/sf2/FluidR3_GM.sf2\" You can save the music as a WAV file with the -Ow option, and a OGG with -Ov . FluidSynth Another software synthesizer is FluidSynth : $ fluidsynth -a alsa -m alsa_seq -l -i /usr/share/sounds/sf2/FluidR3_GM.sf2 canon.mid Add the option -F canon.wav to generate a WAV file, instead of listening directly. macOS You can use GarageBand. Windows You can simply play your MIDI files with the Windows Media Player. Online tools You can convert your MIDI files to several audio formats using online tools such as: https://audio.online-convert.com/convert/midi-to-ogg https://www.conversion-tool.com/midi/ With some of them, you can even choose the soundfont. Playing your MIDI file with your synthesizer You can connect your musical keyboard or synthesizer to your computer using a USB / MIDI interface. First price is around 15 € or $. Linux This ALSA command will print the list of the connected MIDI devices: $ aplaymidi -l Port Client name Port name 14 :0 Midi Through Midi Through Port-0 24 :0 E-MU Xmidi 2x2 E-MU Xmidi 2x2 MIDI 1 24 :1 E-MU Xmidi 2x2 E-MU Xmidi 2x2 MIDI 2 If the synthesizer is connected to the port 24:0, this command will play the MIDI file: $ aplaymidi -p 24 :0 canon.mid Importing your MIDI file in other softwares You can of course import your .mid file into any sequencer like LMMS (Linux, Windows, macOS) or Rosegarden . Contributing Post a message in the GitHub Issues tab to discuss the function you want to work on. Concerning coding conventions, stay consistent with the style of the project. When ready, make a Pull Request . MIDI technical information https://en.wikipedia.org/wiki/MIDI A simple introduction to MIDI files: Oliveira, H. M. de, and R. C. de Oliveira, \"Understanding MIDI: A Painless Tutorial on Midi Format\", arXiv, 15th May 2017, http://arxiv.org/abs/1705.05322. Somascape , a complete MIDI 1.0 documentation. Standard MIDI Files Standard MIDI-File Format Spec. 1.1, updated (fr) La norme MIDI et les fichiers MIDI Codage Variable Length Quantity General MIDI instruments MIDI notes Control Change Messages (fr) Introduction au MIDI : les control change Soundfont CGM3.01 (1.57 Gb) Bibliography English Jean-Claude Risset, Computer music: why ? , 2003. Dave Benson, Music - A Mathematical Offering , 2008. Illiac Suite (>Wikipedia) . About the history of electronic music: https://github.com/vmagnin/forsynth/blob/main/ELECTRONIC_MUSIC_HISTORY.md French Vincent Magnin, \"Avec MIDI, lancez-vous dans la musique assistée par ordinateur !\" , Linux Pratique , HS n°29, février 2014. Vincent Magnin, \"Format MIDI : composez en C !\" , GNU/Linux Magazine, n°196, sept. 2016. Vincent Magnin, \"Format MIDI et musique algorithmique\" , GNU/Linux Magazine, n°198, nov. 2016. Vincent Magnin, \"Lancez-vous dans la « dance music » avec Linux MultiMedia Studio !\" , Linux Pratique, n°82, mars 2014. Vincent Magnin, \"Composez librement avec le séquenceur Rosegarden\" , Linux Pratique, HS n°29, février 2014. Moreno Andreatta, \"Musique algorithmique\" , 2009. Laurent de Wilde, Les fous du son - D'Edison à nos jours , Éditions Grasset et Fasquelle, 560 pages, 2016, ISBN 9782246859277. Laurent Fichet, Les théories scientifiques de la musique aux XIXe et XXe siècles , Vrin, 1996, ISBN 978-2-7116-4284-7. Guillaume Kosmicki , Musiques électroniques - Des avant-gardes aux dance floors , Éditions Le mot et le reste, 2nd edition, 2016, 416 p., ISBN 9782360541928. Bibliothèque Tangente n°11, Mathématiques et musique - des destinées parallèles , Paris : Éditions POLE, septembre 2022, ISBN 9782848842462. Developer Info Vincent Magnin","tags":"home","loc":"index.html"},{"title":"MIDI_file – ForMIDI ","text":"type, public :: MIDI_file The main class you need to create a MIDI file. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: filename integer(kind=int32), private :: size_pos integer, private :: status integer, private :: unit Type-Bound Procedures procedure, public :: Control_Change private  subroutine Control_Change (self, channel, type, ctl_value) Many MIDI parameters can be set by Control Change. See the list. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: type integer, intent(in) :: ctl_value procedure, public :: Note_OFF private  subroutine Note_OFF (self, channel, note, velocity) Writes a Note OFF event. MIDI notes are in the range 0..127\nThe release velocity is in the range 0..127. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), optional :: velocity procedure, public :: Note_ON private  subroutine Note_ON (self, channel, note, velocity) Writes a Note ON event. MIDI notes are in the range 0..127\nThe attack velocity is in the range 1..127 and will set the volume.\nA Note ON event with a zero velocity is equivalent to a Note OFF. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity procedure, public :: Program_Change private  subroutine Program_Change (self, channel, instrument) Each channel (0..15) can use one General MIDI instrument (0..127) at\na time. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: instrument procedure, public :: close private  subroutine close (self) Closes the MIDI file. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self procedure, public :: cue_point private  subroutine cue_point (self, text) Cue Point event: FF 07 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: delta_time private  subroutine delta_time (self, ticks) Each MIDI event must be preceded by a delay called \"delta time\",\nexpressed in MIDI ticks. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: ticks procedure, public :: end_of_track private  subroutine end_of_track (self) A track must end with 0xFF2F00. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self procedure, public :: get_name private  function get_name (self) Returns the name of the MIDI file: Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self Return Value character(len=len(self%filename)) procedure, public :: instrument_name private  subroutine instrument_name (self, text) Instrument Name event: FF 04 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: lyric private  subroutine lyric (self, text) Lyric event: FF 05 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: marker private  subroutine marker (self, text) Marker event: FF 06 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: new private  subroutine new (self, file_name, format, tracks, divisions, tempo, time_signature, copyright, text_event) Create a new MIDI file and its metadata track.\nConcerning the \"divisions\" argument, ForMIDI uses the \"metrical timing\"\nscheme, defining the number of ticks in a quarter note. The \"timecode\"\nscheme is not implemented.\nSMF format:\n0: only one track in the file\n1: several tracks played together (generally used)\n2: several tracks played sequentially Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: file_name integer, intent(in) :: format integer, intent(in) :: tracks integer, intent(in) :: divisions integer, intent(in) :: tempo integer, intent(in), optional :: time_signature (:) character(len=*), intent(in), optional :: copyright character(len=*), intent(in), optional :: text_event procedure, public :: play_broken_chord private  subroutine play_broken_chord (self, channel, note, chord, velocity, value) Writes a broken chord using an array containing the intervals\n(see the music_common module).\nFor the moment, each note has the same duration.\nhttps://en.wikipedia.org/wiki/Arpeggio Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value procedure, public :: play_chord private  subroutine play_chord (self, channel, note, chord, velocity, value) Writes a chord, waits for its duration, and writes the OFF events Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value procedure, public :: play_note private  subroutine play_note (self, channel, note, velocity, value) Write a Note ON event, waits for its duration, and writes a Note OFF. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity integer, intent(in) :: value procedure, public :: sequence_track_name private  subroutine sequence_track_name (self, text) Sequence or Track Name event: FF 03 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: set_tempo private  subroutine set_tempo (self, duration) Specifies a tempo change by writing the duration of a quarter note\nexpressed in µs. It is coded on 3 bytes: from 1 µs to 256**3 µs ~ 16.7 s.\nA duration of 500000 µs = 0.5 s is equivalent to a 120 bpm tempo.\nhttps://en.wikipedia.org/wiki/Tempo\nMIDI events must always be preceded by a \"delta time\", even if null: Read more… Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: duration procedure, public :: set_time_signature private  subroutine set_time_signature (self, numerator, denominator, metronome, tsnotes) The time signature includes the numerator,  the denominator,\nthe number of MIDI clocks between metronome ticks,\n(there are 24 MIDI clocks per quarter note)\nand the number of 32nd notes in a quarter note.\nThe number of \"MIDI clocks\" between metronome clicks. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: numerator integer, intent(in) :: denominator integer, intent(in) :: metronome integer, intent(in), optional :: tsnotes procedure, public :: text_event private  subroutine text_event (self, text) Text event: FF 01 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, public :: track_header private  subroutine track_header (self, track_name, text_event) Writes a track header and stores the position where the size of the\ntrack will be written when the track will be closed. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in), optional :: track_name character(len=*), intent(in), optional :: text_event procedure, private :: copyright_notice private  subroutine copyright_notice (self, text) Copyright Notice event: FF 02 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text procedure, private :: init_formidi private  subroutine init_formidi (self) Verifies the needed data types. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self procedure, private :: write_string private  subroutine write_string (self, event, text) This subroutine is used my many events.\nThe text must be coded in ASCII (7 bits). Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: event character(len=*), intent(in) :: text procedure, private :: write_track_size private  subroutine write_track_size (self) Must be called when the track is finished. It writes its size at the\nmemorized position in the track header. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self procedure, private :: write_variable_length_quantity private  subroutine write_variable_length_quantity (self, i) Writes the integer i in the MIDI file\nusing the variable length quantity representation: Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer(kind=int32), intent(in) :: i Source Code type MIDI_file character ( len = :), private , allocatable :: filename ! Output unit and file status: integer , private :: unit integer , private :: status ! To store where to write the size of a track in the file: integer ( int32 ), private :: size_pos contains procedure , private :: init_formidi procedure , private :: write_variable_length_quantity procedure :: new procedure :: track_header procedure :: set_tempo procedure :: set_time_signature procedure :: end_of_track procedure :: get_name procedure , private :: write_track_size procedure :: Program_Change procedure :: play_note procedure :: play_chord procedure :: play_broken_chord procedure :: close procedure :: Control_Change procedure :: Note_ON procedure :: Note_OFF procedure :: delta_time procedure , private :: write_string procedure :: text_event procedure , private :: copyright_notice procedure :: sequence_track_name procedure :: instrument_name procedure :: lyric procedure :: marker procedure :: cue_point end type MIDI_file","tags":"","loc":"type/midi_file.html"},{"title":"MIDI_Note – ForMIDI","text":"public  function MIDI_Note(note) Returns the MIDI note number, from 12 (C0) to 127 (G9).\nThe note name is composed of two or three characters, \nfor example \"A4\", \"A#4\", \"Ab4\", where the final character is \nthe octave. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: note Return Value integer Called by proc~~midi_note~~CalledByGraph proc~midi_note MIDI_Note program~blues blues program~blues->proc~midi_note program~canon canon program~canon->proc~midi_note program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~midi_note program~la_folia la_folia program~la_folia->proc~midi_note program~third_kind third_kind program~third_kind->proc~midi_note Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer function MIDI_Note ( note ) character ( * ), intent ( in ) :: note ! 0 <= octave <=9 integer :: octave ! Gap relative to A4 (note 69) in semitones: integer :: gap ! ASCII code of the 0 character: integer , parameter :: zero = iachar ( '0' ) select case ( note ( 1 : 1 )) case ( 'C' ) gap = - 9 case ( 'D' ) gap = - 7 case ( 'E' ) gap = - 5 case ( 'F' ) gap = - 4 case ( 'G' ) gap = - 2 case ( 'A' ) gap = 0 case ( 'B' ) gap = + 2 case default write ( error_unit , * ) \"ERROR 4: unknown note name!\" error stop 4 end select ! Treating accidentals (sharp, flat) and computing the octave: select case ( note ( 2 : 2 )) case ( 'b' ) gap = gap - 1 octave = iachar ( note ( 3 : 3 )) - zero case ( '#' ) gap = gap + 1 octave = iachar ( note ( 3 : 3 )) - zero case default octave = iachar ( note ( 2 : 2 )) - zero end select if (( octave >= 0 ) . and . ( octave <= 9 )) then gap = gap + ( octave - 4 ) * 12 else write ( error_unit , * ) \"ERROR 5: octave out of bounds [0; 9]\" error stop 5 end if ! Computing and returning the MIDI note number (A4 is 69): MIDI_Note = 69 + gap end function MIDI_Note","tags":"","loc":"proc/midi_note.html"},{"title":"dotted – ForMIDI","text":"public  function dotted(value) Returns the value of a dotted note. Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value integer Called by proc~~dotted~~CalledByGraph proc~dotted dotted program~la_folia la_folia program~la_folia->proc~dotted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dotted.html"},{"title":"note_name – ForMIDI","text":"public  function note_name(MIDI_note) result(name) Receives a MIDI note (for example 69),\nand returns the name of the note (for example A4).\nIt works also with the octave -1, although most of its notes\nare too low for hearing. Arguments Type Intent Optional Attributes Name integer, intent(in) :: MIDI_note Return Value character(len=4) Calls proc~~note_name~~CallsGraph proc~note_name note_name proc~checked_int8 checked_int8 proc~note_name->proc~checked_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/note_name.html"},{"title":"variable_length_quantity – ForMIDI","text":"public pure function variable_length_quantity(i) result(VLQ) MIDI delta times are composed of one to four bytes, depending on their\nvalues. If there is still bytes to write, the MSB (most significant bit)\nof the current byte is 1, else 0.\nThis functions is automatically tested.\nhttps://en.wikipedia.org/wiki/Variable-length_quantity Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value integer(kind=int8), allocatable, dimension(:) Called by proc~~variable_length_quantity~~CalledByGraph proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity proc~delta_time MIDI_file%delta_time proc~delta_time->proc~write_variable_length_quantity proc~write_string MIDI_file%write_string proc~write_string->proc~write_variable_length_quantity proc~write_string->proc~delta_time proc~control_change MIDI_file%Control_Change proc~control_change->proc~delta_time proc~copyright_notice MIDI_file%copyright_notice proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~end_of_track MIDI_file%end_of_track proc~end_of_track->proc~delta_time proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~delta_time proc~play_chord MIDI_file%play_chord proc~play_chord->proc~delta_time proc~play_note MIDI_file%play_note proc~play_note->proc~delta_time proc~program_change MIDI_file%Program_Change proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~set_tempo MIDI_file%set_tempo proc~set_tempo->proc~delta_time proc~set_time_signature MIDI_file%set_time_signature proc~set_time_signature->proc~delta_time proc~text_event MIDI_file%text_event proc~text_event->proc~write_string program~blues blues program~blues->proc~delta_time program~blues->proc~control_change program~blues->proc~end_of_track program~blues->proc~play_chord program~blues->proc~program_change proc~new MIDI_file%new program~blues->proc~new proc~track_header MIDI_file%track_header program~blues->proc~track_header proc~new->proc~copyright_notice proc~new->proc~end_of_track proc~new->proc~set_tempo proc~new->proc~set_time_signature proc~new->proc~text_event proc~new->proc~track_header proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event program~canon canon program~canon->proc~control_change program~canon->proc~end_of_track program~canon->proc~play_note program~canon->proc~program_change program~canon->proc~new program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~control_change program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~play_chord program~circle_of_fifths->proc~program_change program~circle_of_fifths->proc~new program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~control_change program~la_folia->proc~end_of_track program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~la_folia->proc~program_change program~la_folia->proc~new program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~end_of_track program~third_kind->proc~play_note program~third_kind->proc~program_change program~third_kind->proc~new program~third_kind->proc~track_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function variable_length_quantity ( i ) result ( VLQ ) integer ( int32 ), intent ( in ) :: i integer ( int8 ), allocatable , dimension (:) :: VLQ integer ( int32 ) :: j , again ! A First In Last Out 4 bytes stack (or Last In First Out): integer ( int32 ) :: filo ! We use a variable j because i has intent(in): j = i filo = 0 ! The 7 least significant bits are placed in filo (0x7F = 0b01111111): filo = iand ( j , z '7F' ) ! They are now eliminated from j by shifting bits of j 7 places ! to the right (zeros are introduced on the left): j = ishft ( j , - 7 ) ! The same process is a applied until j is empty: do if ( j == 0 ) exit ! The bits already in filo are shifted 1 byte to the left ! (filo is Little Endian): filo = ishft ( filo , + 8 ) ! A byte of j with the most signicant bit set to 1 (0x80 = 0b10000000) ! can now be added on the right of filo: filo = filo + ior ( iand ( j , z '7F' ), z '80' ) ! Preparing next iteration: j = ishft ( j , - 7 ) end do ! Starting with a void array: allocate ( VLQ ( 0 )) ! The bytes accumulated in filo are now written in the VLQ array ! in the reverse order (MIDI files are Big Endian): do ! Appending the LSB of filo in the VLQ array: VLQ = [ VLQ , int ( filo , int8 ) ] ! Is the bit 8 a 1? (meaning there is still other bytes to read): again = iand ( filo , z '80' ) if ( again /= 0 ) then ! The written LSB can now be eliminated before next iteration: filo = ishft ( filo , - 8 ) else ! Nothing left to write: exit end if end do end function variable_length_quantity","tags":"","loc":"proc/variable_length_quantity.html"},{"title":"get_name – ForMIDI","text":"private  function get_name(self) Returns the name of the MIDI file: Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self Return Value character(len=len(self%filename)) Called by proc~~get_name~~CalledByGraph proc~get_name MIDI_file%get_name program~blues blues program~blues->proc~get_name program~canon canon program~canon->proc~get_name program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~get_name program~la_folia la_folia program~la_folia->proc~get_name program~third_kind third_kind program~third_kind->proc~get_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_name.html"},{"title":"Control_Change – ForMIDI","text":"private  subroutine Control_Change(self, channel, type, ctl_value) Many MIDI parameters can be set by Control Change. See the list. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: type integer, intent(in) :: ctl_value Calls proc~~control_change~~CallsGraph proc~control_change MIDI_file%Control_Change proc~checked_int8 checked_int8 proc~control_change->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~control_change->proc~delta_time proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~control_change~~CalledByGraph proc~control_change MIDI_file%Control_Change program~blues blues program~blues->proc~control_change program~canon canon program~canon->proc~control_change program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~control_change program~la_folia la_folia program~la_folia->proc~control_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/control_change.html"},{"title":"Note_OFF – ForMIDI","text":"private  subroutine Note_OFF(self, channel, note, velocity) Writes a Note OFF event. MIDI notes are in the range 0..127\nThe release velocity is in the range 0..127. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), optional :: velocity Calls proc~~note_off~~CallsGraph proc~note_off MIDI_file%Note_OFF proc~checked_int8 checked_int8 proc~note_off->proc~checked_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~note_off~~CalledByGraph proc~note_off MIDI_file%Note_OFF proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~note_off proc~play_chord MIDI_file%play_chord proc~play_chord->proc~note_off proc~play_note MIDI_file%play_note proc~play_note->proc~note_off program~blues blues program~blues->proc~note_off program~blues->proc~play_chord program~canon canon program~canon->proc~play_note program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~play_chord program~la_folia la_folia program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~third_kind third_kind program~third_kind->proc~play_note Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Note_OFF ( self , channel , note , velocity ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note ! 8 bits integer , optional , intent ( in ) :: velocity ! 8 bits integer ( int8 ) :: octets ( 0 : 2 ) octets ( 0 ) = OFF + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( note ) if ( present ( velocity )) then octets ( 2 ) = checked_int8 ( velocity ) else octets ( 2 ) = 64 ! Default value if no velocity captor end if write ( self % unit , iostat = self % status ) octets end subroutine Note_OFF","tags":"","loc":"proc/note_off.html"},{"title":"Note_ON – ForMIDI","text":"private  subroutine Note_ON(self, channel, note, velocity) Writes a Note ON event. MIDI notes are in the range 0..127\nThe attack velocity is in the range 1..127 and will set the volume.\nA Note ON event with a zero velocity is equivalent to a Note OFF. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity Calls proc~~note_on~~CallsGraph proc~note_on MIDI_file%Note_ON proc~checked_int8 checked_int8 proc~note_on->proc~checked_int8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~note_on~~CalledByGraph proc~note_on MIDI_file%Note_ON proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~note_on proc~play_chord MIDI_file%play_chord proc~play_chord->proc~note_on proc~play_note MIDI_file%play_note proc~play_note->proc~note_on program~blues blues program~blues->proc~note_on program~blues->proc~play_chord program~canon canon program~canon->proc~play_note program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~play_chord program~la_folia la_folia program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~third_kind third_kind program~third_kind->proc~play_note Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine Note_ON ( self , channel , note , velocity ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note , velocity ! 8 bits integer ( int8 ) :: octets ( 0 : 2 ) octets ( 0 ) = ON + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( note ) octets ( 2 ) = checked_int8 ( velocity ) write ( self % unit , iostat = self % status ) octets end subroutine Note_ON","tags":"","loc":"proc/note_on.html"},{"title":"Program_Change – ForMIDI","text":"private  subroutine Program_Change(self, channel, instrument) Each channel (0..15) can use one General MIDI instrument (0..127) at\na time. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: instrument Calls proc~~program_change~~CallsGraph proc~program_change MIDI_file%Program_Change proc~checked_int8 checked_int8 proc~program_change->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~program_change->proc~delta_time proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~program_change~~CalledByGraph proc~program_change MIDI_file%Program_Change program~blues blues program~blues->proc~program_change program~canon canon program~canon->proc~program_change program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~program_change program~la_folia la_folia program~la_folia->proc~program_change program~third_kind third_kind program~third_kind->proc~program_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/program_change.html"},{"title":"close – ForMIDI","text":"private  subroutine close(self) Closes the MIDI file. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self","tags":"","loc":"proc/close.html"},{"title":"copyright_notice – ForMIDI","text":"private  subroutine copyright_notice(self, text) Copyright Notice event: FF 02 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~copyright_notice~~CallsGraph proc~copyright_notice MIDI_file%copyright_notice proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copyright_notice~~CalledByGraph proc~copyright_notice MIDI_file%copyright_notice proc~new MIDI_file%new proc~new->proc~copyright_notice program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/copyright_notice.html"},{"title":"cue_point – ForMIDI","text":"private  subroutine cue_point(self, text) Cue Point event: FF 07 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~cue_point~~CallsGraph proc~cue_point MIDI_file%cue_point proc~write_string MIDI_file%write_string proc~cue_point->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cue_point.html"},{"title":"delta_time – ForMIDI","text":"private  subroutine delta_time(self, ticks) Each MIDI event must be preceded by a delay called \"delta time\",\nexpressed in MIDI ticks. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: ticks Calls proc~~delta_time~~CallsGraph proc~delta_time MIDI_file%delta_time proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~delta_time~~CalledByGraph proc~delta_time MIDI_file%delta_time proc~control_change MIDI_file%Control_Change proc~control_change->proc~delta_time proc~end_of_track MIDI_file%end_of_track proc~end_of_track->proc~delta_time proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~delta_time proc~play_chord MIDI_file%play_chord proc~play_chord->proc~delta_time proc~play_note MIDI_file%play_note proc~play_note->proc~delta_time proc~program_change MIDI_file%Program_Change proc~program_change->proc~delta_time proc~set_tempo MIDI_file%set_tempo proc~set_tempo->proc~delta_time proc~set_time_signature MIDI_file%set_time_signature proc~set_time_signature->proc~delta_time proc~write_string MIDI_file%write_string proc~write_string->proc~delta_time program~blues blues program~blues->proc~delta_time program~blues->proc~control_change program~blues->proc~end_of_track program~blues->proc~play_chord program~blues->proc~program_change proc~new MIDI_file%new program~blues->proc~new proc~track_header MIDI_file%track_header program~blues->proc~track_header proc~copyright_notice MIDI_file%copyright_notice proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~new->proc~end_of_track proc~new->proc~set_tempo proc~new->proc~set_time_signature proc~new->proc~copyright_notice proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~new->proc~track_header proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~text_event->proc~write_string program~canon canon program~canon->proc~control_change program~canon->proc~end_of_track program~canon->proc~play_note program~canon->proc~program_change program~canon->proc~new program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~control_change program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~play_chord program~circle_of_fifths->proc~program_change program~circle_of_fifths->proc~new program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~control_change program~la_folia->proc~end_of_track program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~la_folia->proc~program_change program~la_folia->proc~new program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~end_of_track program~third_kind->proc~play_note program~third_kind->proc~program_change program~third_kind->proc~new program~third_kind->proc~track_header proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/delta_time.html"},{"title":"end_of_track – ForMIDI","text":"private  subroutine end_of_track(self) A track must end with 0xFF2F00. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self Calls proc~~end_of_track~~CallsGraph proc~end_of_track MIDI_file%end_of_track proc~delta_time MIDI_file%delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~end_of_track~~CalledByGraph proc~end_of_track MIDI_file%end_of_track proc~new MIDI_file%new proc~new->proc~end_of_track program~blues blues program~blues->proc~end_of_track program~blues->proc~new program~canon canon program~canon->proc~end_of_track program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~end_of_track program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~end_of_track program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/end_of_track.html"},{"title":"init_formidi – ForMIDI","text":"private  subroutine init_formidi(self) Verifies the needed data types. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self Called by proc~~init_formidi~~CalledByGraph proc~init_formidi MIDI_file%init_formidi proc~new MIDI_file%new proc~new->proc~init_formidi program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_formidi.html"},{"title":"instrument_name – ForMIDI","text":"private  subroutine instrument_name(self, text) Instrument Name event: FF 04 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~instrument_name~~CallsGraph proc~instrument_name MIDI_file%instrument_name proc~write_string MIDI_file%write_string proc~instrument_name->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/instrument_name.html"},{"title":"lyric – ForMIDI","text":"private  subroutine lyric(self, text) Lyric event: FF 05 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~lyric~~CallsGraph proc~lyric MIDI_file%lyric proc~write_string MIDI_file%write_string proc~lyric->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lyric.html"},{"title":"marker – ForMIDI","text":"private  subroutine marker(self, text) Marker event: FF 06 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~marker~~CallsGraph proc~marker MIDI_file%marker proc~write_string MIDI_file%write_string proc~marker->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/marker.html"},{"title":"new – ForMIDI","text":"private  subroutine new(self, file_name, format, tracks, divisions, tempo, time_signature, copyright, text_event) Create a new MIDI file and its metadata track.\nConcerning the \"divisions\" argument, ForMIDI uses the \"metrical timing\"\nscheme, defining the number of ticks in a quarter note. The \"timecode\"\nscheme is not implemented.\nSMF format:\n0: only one track in the file\n1: several tracks played together (generally used)\n2: several tracks played sequentially Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: file_name integer, intent(in) :: format integer, intent(in) :: tracks integer, intent(in) :: divisions integer, intent(in) :: tempo integer, intent(in), optional :: time_signature (:) character(len=*), intent(in), optional :: copyright character(len=*), intent(in), optional :: text_event Calls proc~~new~~CallsGraph proc~new MIDI_file%new proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~checked_int32 checked_int32 proc~new->proc~checked_int32 proc~checked_int8 checked_int8 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~end_of_track MIDI_file%end_of_track proc~new->proc~end_of_track proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~track_header MIDI_file%track_header proc~new->proc~track_header proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~delta_time MIDI_file%delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~set_time_signature->proc~delta_time proc~text_event->proc~write_string proc~track_header->proc~text_event proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~sequence_track_name->proc~write_string proc~write_string->proc~checked_int8 proc~write_string->proc~delta_time proc~write_string->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~new~~CalledByGraph proc~new MIDI_file%new program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/new.html"},{"title":"play_broken_chord – ForMIDI","text":"private  subroutine play_broken_chord(self, channel, note, chord, velocity, value) Writes a broken chord using an array containing the intervals\n(see the music_common module).\nFor the moment, each note has the same duration.\nhttps://en.wikipedia.org/wiki/Arpeggio Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value Calls proc~~play_broken_chord~~CallsGraph proc~play_broken_chord MIDI_file%play_broken_chord proc~checked_int32 checked_int32 proc~play_broken_chord->proc~checked_int32 proc~delta_time MIDI_file%delta_time proc~play_broken_chord->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_broken_chord->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_broken_chord->proc~note_on proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int8 checked_int8 proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~play_broken_chord~~CalledByGraph proc~play_broken_chord MIDI_file%play_broken_chord program~la_folia la_folia program~la_folia->proc~play_broken_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine play_broken_chord ( self , channel , note , chord , velocity , value ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note ! 8 bits integer , dimension (:), intent ( in ) :: chord integer , intent ( in ) :: velocity ! 8 bits integer , intent ( in ) :: value ! 32 bits integer ( int32 ) :: dnote , residual integer :: i dnote = nint ( real ( checked_int32 ( value )) / size ( chord )) ! The MIDI duration being an integer, the last note of the chord may ! have a slightly different duration to keep the total duration exact: residual = checked_int32 ( value ) - dnote * ( size ( chord ) - 1 ) call self % delta_time ( 0 ) do i = 1 , size ( chord ) call self % Note_ON ( channel , note + chord ( i ), velocity ) if ( i < size ( chord )) then call self % delta_time ( dnote ) else call self % delta_time ( residual ) end if end do do i = 1 , size ( chord ) call self % Note_OFF ( channel , note + chord ( i )) ! The delta time must always be placed before a note: if ( i < size ( chord )) call self % delta_time ( 0 ) end do end subroutine play_broken_chord","tags":"","loc":"proc/play_broken_chord.html"},{"title":"play_chord – ForMIDI","text":"private  subroutine play_chord(self, channel, note, chord, velocity, value) Writes a chord, waits for its duration, and writes the OFF events Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value Calls proc~~play_chord~~CallsGraph proc~play_chord MIDI_file%play_chord proc~checked_int32 checked_int32 proc~play_chord->proc~checked_int32 proc~delta_time MIDI_file%delta_time proc~play_chord->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_chord->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_chord->proc~note_on proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int8 checked_int8 proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~play_chord~~CalledByGraph proc~play_chord MIDI_file%play_chord program~blues blues program~blues->proc~play_chord program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~play_chord program~la_folia la_folia program~la_folia->proc~play_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/play_chord.html"},{"title":"play_note – ForMIDI","text":"private  subroutine play_note(self, channel, note, velocity, value) Write a Note ON event, waits for its duration, and writes a Note OFF. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity integer, intent(in) :: value Calls proc~~play_note~~CallsGraph proc~play_note MIDI_file%play_note proc~checked_int32 checked_int32 proc~play_note->proc~checked_int32 proc~delta_time MIDI_file%delta_time proc~play_note->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_note->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_note->proc~note_on proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int8 checked_int8 proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~play_note~~CalledByGraph proc~play_note MIDI_file%play_note program~canon canon program~canon->proc~play_note program~third_kind third_kind program~third_kind->proc~play_note Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/play_note.html"},{"title":"sequence_track_name – ForMIDI","text":"private  subroutine sequence_track_name(self, text) Sequence or Track Name event: FF 03 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~sequence_track_name~~CallsGraph proc~sequence_track_name MIDI_file%sequence_track_name proc~write_string MIDI_file%write_string proc~sequence_track_name->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sequence_track_name~~CalledByGraph proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header MIDI_file%track_header proc~track_header->proc~sequence_track_name proc~new MIDI_file%new proc~new->proc~track_header program~blues blues program~blues->proc~track_header program~blues->proc~new program~canon canon program~canon->proc~track_header program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~track_header program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~track_header program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~track_header program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/sequence_track_name.html"},{"title":"set_tempo – ForMIDI","text":"private  subroutine set_tempo(self, duration) Specifies a tempo change by writing the duration of a quarter note\nexpressed in µs. It is coded on 3 bytes: from 1 µs to 256**3 µs ~ 16.7 s.\nA duration of 500000 µs = 0.5 s is equivalent to a 120 bpm tempo.\nhttps://en.wikipedia.org/wiki/Tempo\nMIDI events must always be preceded by a \"delta time\", even if null: Metadata always begin by 0xFF. Here, these codes mean we will define\nthe music tempo: Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: duration Calls proc~~set_tempo~~CallsGraph proc~set_tempo MIDI_file%set_tempo proc~checked_int32 checked_int32 proc~set_tempo->proc~checked_int32 proc~delta_time MIDI_file%delta_time proc~set_tempo->proc~delta_time proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_tempo~~CalledByGraph proc~set_tempo MIDI_file%set_tempo proc~new MIDI_file%new proc~new->proc~set_tempo program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_tempo.html"},{"title":"set_time_signature – ForMIDI","text":"private  subroutine set_time_signature(self, numerator, denominator, metronome, tsnotes) The time signature includes the numerator,  the denominator,\nthe number of MIDI clocks between metronome ticks,\n(there are 24 MIDI clocks per quarter note)\nand the number of 32nd notes in a quarter note.\nThe number of \"MIDI clocks\" between metronome clicks. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: numerator integer, intent(in) :: denominator integer, intent(in) :: metronome integer, intent(in), optional :: tsnotes Calls proc~~set_time_signature~~CallsGraph proc~set_time_signature MIDI_file%set_time_signature proc~checked_int8 checked_int8 proc~set_time_signature->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~set_time_signature->proc~delta_time proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_time_signature~~CalledByGraph proc~set_time_signature MIDI_file%set_time_signature proc~new MIDI_file%new proc~new->proc~set_time_signature program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_time_signature ( self , numerator , denominator , metronome , tsnotes ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: numerator , denominator , metronome ! 8 bits integer , optional , intent ( in ) :: tsnotes ! 8 bits integer ( int8 ) :: octets ( 0 : 6 ) ! MIDI events must always be preceded by a \"delta time\", even if null: call self % delta_time ( 0 ) ! Metadata always begin by 0xFF. Here, these bytes mean we will define ! the time signature: octets ( 0 ) = int ( z 'FF' , int8 ) octets ( 1 ) = int ( z '58' , int8 ) octets ( 2 ) = int ( z '04' , int8 ) ! The data: octets ( 3 ) = checked_int8 ( numerator ) ! That byte is the power of 2 of the denominator, for example 3 for ! a denominator whose value is 8: octets ( 4 ) = checked_int8 ( nint ( log ( real ( denominator )) / log ( 2.0 ))) octets ( 5 ) = checked_int8 ( metronome ) if ( present ( tsnotes )) then octets ( 6 ) = checked_int8 ( tsnotes ) else octets ( 6 ) = 8_int8 ! Default value end if write ( self % unit , iostat = self % status ) octets end subroutine set_time_signature","tags":"","loc":"proc/set_time_signature.html"},{"title":"text_event – ForMIDI","text":"private  subroutine text_event(self, text) Text event: FF 01 len text Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text Calls proc~~text_event~~CallsGraph proc~text_event MIDI_file%text_event proc~write_string MIDI_file%write_string proc~text_event->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~text_event~~CalledByGraph proc~text_event MIDI_file%text_event proc~new MIDI_file%new proc~new->proc~text_event proc~track_header MIDI_file%track_header proc~new->proc~track_header proc~track_header->proc~text_event program~blues blues program~blues->proc~new program~blues->proc~track_header program~canon canon program~canon->proc~new program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~new program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~new program~third_kind->proc~track_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/text_event.html"},{"title":"track_header – ForMIDI","text":"private  subroutine track_header(self, track_name, text_event) Writes a track header and stores the position where the size of the\ntrack will be written when the track will be closed. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in), optional :: track_name character(len=*), intent(in), optional :: text_event Calls proc~~track_header~~CallsGraph proc~track_header MIDI_file%track_header proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~text_event MIDI_file%text_event proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~sequence_track_name->proc~write_string proc~text_event->proc~write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~track_header~~CalledByGraph proc~track_header MIDI_file%track_header proc~new MIDI_file%new proc~new->proc~track_header program~blues blues program~blues->proc~track_header program~blues->proc~new program~canon canon program~canon->proc~track_header program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~track_header program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~track_header program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~track_header program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/track_header.html"},{"title":"write_string – ForMIDI","text":"private  subroutine write_string(self, event, text) This subroutine is used my many events.\nThe text must be coded in ASCII (7 bits). Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: event character(len=*), intent(in) :: text Calls proc~~write_string~~CallsGraph proc~write_string MIDI_file%write_string proc~checked_int8 checked_int8 proc~write_string->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~write_string->proc~delta_time proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~write_string->proc~write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_string~~CalledByGraph proc~write_string MIDI_file%write_string proc~copyright_notice MIDI_file%copyright_notice proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~text_event MIDI_file%text_event proc~text_event->proc~write_string proc~new MIDI_file%new proc~new->proc~copyright_notice proc~new->proc~text_event proc~track_header MIDI_file%track_header proc~new->proc~track_header proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event program~blues blues program~blues->proc~new program~blues->proc~track_header program~canon canon program~canon->proc~new program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~new program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~new program~third_kind->proc~track_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_string.html"},{"title":"write_track_size – ForMIDI","text":"private  subroutine write_track_size(self) Must be called when the track is finished. It writes its size at the\nmemorized position in the track header. Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self Called by proc~~write_track_size~~CalledByGraph proc~write_track_size MIDI_file%write_track_size proc~end_of_track MIDI_file%end_of_track proc~end_of_track->proc~write_track_size proc~new MIDI_file%new proc~new->proc~end_of_track program~blues blues program~blues->proc~end_of_track program~blues->proc~new program~canon canon program~canon->proc~end_of_track program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~end_of_track program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~end_of_track program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_track_size.html"},{"title":"write_variable_length_quantity – ForMIDI","text":"private  subroutine write_variable_length_quantity(self, i) Writes the integer i in the MIDI file\nusing the variable length quantity representation: Type Bound MIDI_file Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer(kind=int32), intent(in) :: i Calls proc~~write_variable_length_quantity~~CallsGraph proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_variable_length_quantity~~CalledByGraph proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time MIDI_file%delta_time proc~delta_time->proc~write_variable_length_quantity proc~write_string MIDI_file%write_string proc~write_string->proc~write_variable_length_quantity proc~write_string->proc~delta_time proc~control_change MIDI_file%Control_Change proc~control_change->proc~delta_time proc~copyright_notice MIDI_file%copyright_notice proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~end_of_track MIDI_file%end_of_track proc~end_of_track->proc~delta_time proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~delta_time proc~play_chord MIDI_file%play_chord proc~play_chord->proc~delta_time proc~play_note MIDI_file%play_note proc~play_note->proc~delta_time proc~program_change MIDI_file%Program_Change proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~set_tempo MIDI_file%set_tempo proc~set_tempo->proc~delta_time proc~set_time_signature MIDI_file%set_time_signature proc~set_time_signature->proc~delta_time proc~text_event MIDI_file%text_event proc~text_event->proc~write_string program~blues blues program~blues->proc~delta_time program~blues->proc~control_change program~blues->proc~end_of_track program~blues->proc~play_chord program~blues->proc~program_change proc~new MIDI_file%new program~blues->proc~new proc~track_header MIDI_file%track_header program~blues->proc~track_header proc~new->proc~copyright_notice proc~new->proc~end_of_track proc~new->proc~set_tempo proc~new->proc~set_time_signature proc~new->proc~text_event proc~new->proc~track_header proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event program~canon canon program~canon->proc~control_change program~canon->proc~end_of_track program~canon->proc~play_note program~canon->proc~program_change program~canon->proc~new program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~control_change program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~play_chord program~circle_of_fifths->proc~program_change program~circle_of_fifths->proc~new program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~control_change program~la_folia->proc~end_of_track program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~la_folia->proc~program_change program~la_folia->proc~new program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~end_of_track program~third_kind->proc~play_note program~third_kind->proc~program_change program~third_kind->proc~new program~third_kind->proc~track_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_variable_length_quantity ( self , i ) class ( MIDI_file ), intent ( inout ) :: self integer ( int32 ), intent ( in ) :: i integer ( int32 ) :: j integer ( int8 ), allocatable , dimension (:) :: array ! The maximum possible MIDI value: if ( i > int ( z '0FFFFFFF' , int32 )) then write ( error_unit , * ) \"ERROR 2: delay > 0x0FFFFFFF ! \" , i error stop 2 end if array = variable_length_quantity ( i ) ! The bytes are now written in the file: do j = 1 , size ( array ) write ( self % unit , iostat = self % status ) array ( j ) end do end subroutine write_variable_length_quantity","tags":"","loc":"proc/write_variable_length_quantity.html"},{"title":"checked_int16 – ForMIDI","text":"public  function checked_int16(i) result(i16) Receives a default kind integer, checks its bounds (Fortran signed int),\nfixes it if needed, and returns an int16: Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer(kind=int16) Called by proc~~checked_int16~~CalledByGraph proc~checked_int16 checked_int16 proc~new MIDI_file%new proc~new->proc~checked_int16 program~blues blues program~blues->proc~new program~canon canon program~canon->proc~new program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~la_folia la_folia program~la_folia->proc~new program~third_kind third_kind program~third_kind->proc~new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/checked_int16.html"},{"title":"checked_int32 – ForMIDI","text":"public  function checked_int32(i) result(i32) Receives a default kind integer, checks its bounds (Fortran signed int),\nfixes it if needed, and returns an int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer(kind=int32) Called by proc~~checked_int32~~CalledByGraph proc~checked_int32 checked_int32 proc~delta_time MIDI_file%delta_time proc~delta_time->proc~checked_int32 proc~new MIDI_file%new proc~new->proc~checked_int32 proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~end_of_track MIDI_file%end_of_track proc~new->proc~end_of_track proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~track_header MIDI_file%track_header proc~new->proc~track_header proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~checked_int32 proc~play_broken_chord->proc~delta_time proc~play_chord MIDI_file%play_chord proc~play_chord->proc~checked_int32 proc~play_chord->proc~delta_time proc~play_note MIDI_file%play_note proc~play_note->proc~checked_int32 proc~play_note->proc~delta_time proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~control_change MIDI_file%Control_Change proc~control_change->proc~delta_time proc~end_of_track->proc~delta_time proc~program_change MIDI_file%Program_Change proc~program_change->proc~delta_time proc~set_time_signature->proc~delta_time proc~write_string MIDI_file%write_string proc~write_string->proc~delta_time program~blues blues program~blues->proc~delta_time program~blues->proc~new program~blues->proc~play_chord program~blues->proc~control_change program~blues->proc~end_of_track program~blues->proc~program_change program~blues->proc~track_header program~canon canon program~canon->proc~new program~canon->proc~play_note program~canon->proc~control_change program~canon->proc~end_of_track program~canon->proc~program_change program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~new program~circle_of_fifths->proc~play_chord program~circle_of_fifths->proc~control_change program~circle_of_fifths->proc~end_of_track program~circle_of_fifths->proc~program_change program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~new program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~la_folia->proc~control_change program~la_folia->proc~end_of_track program~la_folia->proc~program_change program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~new program~third_kind->proc~play_note program~third_kind->proc~end_of_track program~third_kind->proc~program_change program~third_kind->proc~track_header proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~text_event->proc~write_string proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/checked_int32.html"},{"title":"checked_int8 – ForMIDI","text":"public  function checked_int8(i, upper) result(i8) Receives a default kind integer, checks its MIDI bounds (15 or 127),\nfixes it if needed, and returns an int8: Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in), optional :: upper Return Value integer(kind=int8) Called by proc~~checked_int8~~CalledByGraph proc~checked_int8 checked_int8 proc~control_change MIDI_file%Control_Change proc~control_change->proc~checked_int8 proc~new MIDI_file%new proc~new->proc~checked_int8 proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~track_header MIDI_file%track_header proc~new->proc~track_header proc~note_name note_name proc~note_name->proc~checked_int8 proc~note_off MIDI_file%Note_OFF proc~note_off->proc~checked_int8 proc~note_on MIDI_file%Note_ON proc~note_on->proc~checked_int8 proc~program_change MIDI_file%Program_Change proc~program_change->proc~checked_int8 proc~set_time_signature->proc~checked_int8 proc~write_string MIDI_file%write_string proc~write_string->proc~checked_int8 proc~copyright_notice->proc~write_string proc~cue_point MIDI_file%cue_point proc~cue_point->proc~write_string proc~instrument_name MIDI_file%instrument_name proc~instrument_name->proc~write_string proc~lyric MIDI_file%lyric proc~lyric->proc~write_string proc~marker MIDI_file%marker proc~marker->proc~write_string proc~play_broken_chord MIDI_file%play_broken_chord proc~play_broken_chord->proc~note_off proc~play_broken_chord->proc~note_on proc~play_chord MIDI_file%play_chord proc~play_chord->proc~note_off proc~play_chord->proc~note_on proc~play_note MIDI_file%play_note proc~play_note->proc~note_off proc~play_note->proc~note_on proc~sequence_track_name MIDI_file%sequence_track_name proc~sequence_track_name->proc~write_string proc~text_event->proc~write_string program~blues blues program~blues->proc~control_change program~blues->proc~new program~blues->proc~note_off program~blues->proc~note_on program~blues->proc~program_change program~blues->proc~play_chord program~blues->proc~track_header program~canon canon program~canon->proc~control_change program~canon->proc~new program~canon->proc~program_change program~canon->proc~play_note program~canon->proc~track_header program~circle_of_fifths circle_of_fifths program~circle_of_fifths->proc~control_change program~circle_of_fifths->proc~new program~circle_of_fifths->proc~program_change program~circle_of_fifths->proc~play_chord program~circle_of_fifths->proc~track_header program~la_folia la_folia program~la_folia->proc~control_change program~la_folia->proc~new program~la_folia->proc~program_change program~la_folia->proc~play_broken_chord program~la_folia->proc~play_chord program~la_folia->proc~track_header program~third_kind third_kind program~third_kind->proc~new program~third_kind->proc~program_change program~third_kind->proc~play_note program~third_kind->proc~track_header proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/checked_int8.html"},{"title":"analyze – ForMIDI","text":"subroutine analyze(string, note, chord_type, note_value) Receives a string with an encoded chords, and returns its fundamental,\nthe type of chord and its encoded value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=3), intent(out) :: note character(len=3), intent(out) :: chord_type character(len=3), intent(out) :: note_value Called by proc~~analyze~~CalledByGraph proc~analyze analyze program~la_folia la_folia program~la_folia->proc~analyze Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/analyze.html"},{"title":"music_common – ForMIDI","text":"Contains music theory elements: scales, circle of fifths, chords, etc. This file will be kept identical in the ForMIDI and ForSynth projects.\nIt could be put in a separate fpm repository and used as a dependency,\nbut for the time being, synchronizing it by hand is sufficient. Used by module~~music_common~~UsedByGraph module~music_common music_common module~music music module~music->module~music_common program~blues blues program~blues->module~music program~canon canon program~canon->module~music program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~music program~la_folia la_folia program~la_folia->module~music program~third_kind third_kind program~third_kind->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), public, parameter,               dimension(1:12) :: CHROMATIC_SCALE = ['C ', 'C#', 'D ', 'D#', 'E ', 'F ', 'F#', 'G ', 'G#', 'A ', 'A#', 'B '] We define some scales, excluding the octave of the first note.\nAlways use the trim() function to remove trailing spaces.\nhttps://en.wikipedia.org/wiki/Scale_(music) character(len=2), public, dimension(1:12) :: CIRCLE_OF_FIFTHS_MAJOR = ['C ', 'G ', 'D ', 'A ', 'E ', 'B ', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F '] Always use the trim() function to remove trailing spaces. character(len=2), public, dimension(1:12) :: CIRCLE_OF_FIFTHS_MINOR = ['A ', 'E ', 'B ', 'F#', 'C#', 'G#', 'Eb', 'Bb', 'F ', 'C ', 'G ', 'D '] integer, public, parameter :: CLUSTER_CHORD (1:12) = [(j, j=0, 11)] integer, public, parameter :: DOMINANT_7TH_CHORD (1:4) = [0, 4, 7, 10] character(len=2), public, parameter,               dimension(1:7) :: HARMONIC_MINOR_SCALE = ['A ', 'B ', 'C ', 'D ', 'E ', 'F ', 'G#'] https://en.wikipedia.org/wiki/Minor_scale#Harmonic_minor_scale character(len=2), public, parameter,               dimension(1:6) :: HEXATONIC_BLUES_SCALE = ['C ', 'Eb', 'F ', 'Gb', 'G ', 'Bb'] https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale integer, public, parameter :: MAJOR_CHORD (1:3) = [0, 4, 7] Some frequent chords.\nThese arrays can be passed to the write_chord() subroutine.\nhttps://en.wikipedia.org/wiki/Chord_(music) character(len=1), public, parameter,               dimension(1:5) :: MAJOR_PENTATONIC_SCALE = ['C', 'D', 'E', 'G', 'A'] https://en.wikipedia.org/wiki/Pentatonic_scale#Major_pentatonic_scale character(len=1), public, parameter,               dimension(1:7) :: MAJOR_SCALE = ['C', 'D', 'E', 'F', 'G', 'A', 'B'] https://en.wikipedia.org/wiki/Major_scale integer, public, parameter :: MINOR_CHORD (1:3) = [0, 3, 7] integer, public, parameter :: POWER_CHORD (1:3) = [0, 7, 12] integer, public, parameter :: SUS2_CHORD (1:3) = [0, 2, 7] integer, public, parameter :: SUS4_CHORD (1:3) = [0, 5, 7] character(len=2), public, parameter,               dimension(1:6) :: WHOLE_TONE_SCALE = ['C ', 'D ', 'E ', 'F#', 'G#', 'A#'] integer, private :: j","tags":"","loc":"module/music_common.html"},{"title":"music – ForMIDI","text":"Offers music parameters and functions specific to MIDI files. Uses iso_fortran_env music_common utilities module~~music~~UsesGraph module~music music iso_fortran_env iso_fortran_env module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~utilities utilities module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~music~~UsedByGraph module~music music program~blues blues program~blues->module~music program~canon canon program~canon->module~music program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~music program~la_folia la_folia program~la_folia->module~music program~third_kind third_kind program~third_kind->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: eighth_note = quarter_note/2 integer, public, parameter :: f_level = 80 integer, public, parameter :: ff_level = 96 integer, public, parameter :: fff_level = 112 integer, public, parameter :: ffff_level = 127 Common note levels expressed as MIDI velocities\nhttps://arxiv.org/pdf/1705.05322 integer, public, parameter :: half_note = 2*quarter_note integer, public, parameter :: mf_level = 64 integer, public, parameter :: mp_level = 53 integer, public, parameter :: p_level = 42 integer, public, parameter :: pp_level = 31 integer, public, parameter :: ppp_level = 20 integer, public, parameter :: pppp_level = 8 integer, public, parameter :: quarter_note = 96 The timing resolution of a MIDI file is defined by the number\nof MIDI ticks in a quarter note: the value 96 is commonly used because\nit can be divided by 2 and 3.\nWe also define the most useful other values.\nhttps://en.wikipedia.org/wiki/Note_value integer, public, parameter :: sixteenth_note = quarter_note/4 integer, public, parameter :: thirty_second_note = quarter_note/8 integer, public, parameter :: whole_note = 4*quarter_note Functions public  function MIDI_Note (note) Returns the MIDI note number, from 12 (C0) to 127 (G9).\nThe note name is composed of two or three characters, \nfor example \"A4\", \"A#4\", \"Ab4\", where the final character is \nthe octave. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: note Return Value integer public  function dotted (value) Returns the value of a dotted note. Arguments Type Intent Optional Attributes Name integer, intent(in) :: value Return Value integer public  function note_name (MIDI_note) result(name) Receives a MIDI note (for example 69),\nand returns the name of the note (for example A4).\nIt works also with the octave -1, although most of its notes\nare too low for hearing. Arguments Type Intent Optional Attributes Name integer, intent(in) :: MIDI_note Return Value character(len=4)","tags":"","loc":"module/music.html"},{"title":"MIDI_file_class – ForMIDI","text":"Contains the main class you need to create a MIDI file. Uses iso_fortran_env utilities module~~midi_file_class~~UsesGraph module~midi_file_class MIDI_file_class iso_fortran_env iso_fortran_env module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~midi_file_class~~UsedByGraph module~midi_file_class MIDI_file_class program~blues blues program~blues->module~midi_file_class program~canon canon program~canon->module~midi_file_class program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~midi_file_class program~la_folia la_folia program~la_folia->module~midi_file_class program~third_kind third_kind program~third_kind->module~midi_file_class Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: OFF = 128 integer, public, parameter :: ON = 144 Used by Note ON and Note OFF events: integer, public, parameter :: drums = 9 Useful MIDI parameters\nPercussions channel (in the 0..15 range): Derived Types type, public :: MIDI_file The main class you need to create a MIDI file. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: filename integer(kind=int32), private :: size_pos integer, private :: status integer, private :: unit Type-Bound Procedures procedure, public :: Control_Change procedure, public :: Note_OFF procedure, public :: Note_ON procedure, public :: Program_Change procedure, public :: close procedure, public :: cue_point procedure, public :: delta_time procedure, public :: end_of_track procedure, public :: get_name procedure, public :: instrument_name procedure, public :: lyric procedure, public :: marker procedure, public :: new procedure, public :: play_broken_chord procedure, public :: play_chord procedure, public :: play_note procedure, public :: sequence_track_name procedure, public :: set_tempo procedure, public :: set_time_signature procedure, public :: text_event procedure, public :: track_header procedure, private :: copyright_notice procedure, private :: init_formidi procedure, private :: write_string procedure, private :: write_track_size procedure, private :: write_variable_length_quantity Functions public pure function variable_length_quantity (i) result(VLQ) MIDI delta times are composed of one to four bytes, depending on their\nvalues. If there is still bytes to write, the MSB (most significant bit)\nof the current byte is 1, else 0.\nThis functions is automatically tested.\nhttps://en.wikipedia.org/wiki/Variable-length_quantity Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value integer(kind=int8), allocatable, dimension(:) private  function get_name (self) Returns the name of the MIDI file: Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self Return Value character(len=len(self%filename)) Subroutines private  subroutine Control_Change (self, channel, type, ctl_value) Many MIDI parameters can be set by Control Change. See the list. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: type integer, intent(in) :: ctl_value private  subroutine Note_OFF (self, channel, note, velocity) Writes a Note OFF event. MIDI notes are in the range 0..127\nThe release velocity is in the range 0..127. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), optional :: velocity private  subroutine Note_ON (self, channel, note, velocity) Writes a Note ON event. MIDI notes are in the range 0..127\nThe attack velocity is in the range 1..127 and will set the volume.\nA Note ON event with a zero velocity is equivalent to a Note OFF. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity private  subroutine Program_Change (self, channel, instrument) Each channel (0..15) can use one General MIDI instrument (0..127) at\na time. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: instrument private  subroutine close (self) Closes the MIDI file. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self private  subroutine copyright_notice (self, text) Copyright Notice event: FF 02 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine cue_point (self, text) Cue Point event: FF 07 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine delta_time (self, ticks) Each MIDI event must be preceded by a delay called \"delta time\",\nexpressed in MIDI ticks. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: ticks private  subroutine end_of_track (self) A track must end with 0xFF2F00. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self private  subroutine init_formidi (self) Verifies the needed data types. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(in) :: self private  subroutine instrument_name (self, text) Instrument Name event: FF 04 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine lyric (self, text) Lyric event: FF 05 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine marker (self, text) Marker event: FF 06 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine new (self, file_name, format, tracks, divisions, tempo, time_signature, copyright, text_event) Create a new MIDI file and its metadata track.\nConcerning the \"divisions\" argument, ForMIDI uses the \"metrical timing\"\nscheme, defining the number of ticks in a quarter note. The \"timecode\"\nscheme is not implemented.\nSMF format:\n0: only one track in the file\n1: several tracks played together (generally used)\n2: several tracks played sequentially Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: file_name integer, intent(in) :: format integer, intent(in) :: tracks integer, intent(in) :: divisions integer, intent(in) :: tempo integer, intent(in), optional :: time_signature (:) character(len=*), intent(in), optional :: copyright character(len=*), intent(in), optional :: text_event private  subroutine play_broken_chord (self, channel, note, chord, velocity, value) Writes a broken chord using an array containing the intervals\n(see the music_common module).\nFor the moment, each note has the same duration.\nhttps://en.wikipedia.org/wiki/Arpeggio Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value private  subroutine play_chord (self, channel, note, chord, velocity, value) Writes a chord, waits for its duration, and writes the OFF events Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in), dimension(:) :: chord integer, intent(in) :: velocity integer, intent(in) :: value private  subroutine play_note (self, channel, note, velocity, value) Write a Note ON event, waits for its duration, and writes a Note OFF. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: channel integer, intent(in) :: note integer, intent(in) :: velocity integer, intent(in) :: value private  subroutine sequence_track_name (self, text) Sequence or Track Name event: FF 03 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine set_tempo (self, duration) Specifies a tempo change by writing the duration of a quarter note\nexpressed in µs. It is coded on 3 bytes: from 1 µs to 256**3 µs ~ 16.7 s.\nA duration of 500000 µs = 0.5 s is equivalent to a 120 bpm tempo.\nhttps://en.wikipedia.org/wiki/Tempo\nMIDI events must always be preceded by a \"delta time\", even if null: Read more… Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: duration private  subroutine set_time_signature (self, numerator, denominator, metronome, tsnotes) The time signature includes the numerator,  the denominator,\nthe number of MIDI clocks between metronome ticks,\n(there are 24 MIDI clocks per quarter note)\nand the number of 32nd notes in a quarter note.\nThe number of \"MIDI clocks\" between metronome clicks. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: numerator integer, intent(in) :: denominator integer, intent(in) :: metronome integer, intent(in), optional :: tsnotes private  subroutine text_event (self, text) Text event: FF 01 len text Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in) :: text private  subroutine track_header (self, track_name, text_event) Writes a track header and stores the position where the size of the\ntrack will be written when the track will be closed. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self character(len=*), intent(in), optional :: track_name character(len=*), intent(in), optional :: text_event private  subroutine write_string (self, event, text) This subroutine is used my many events.\nThe text must be coded in ASCII (7 bits). Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer, intent(in) :: event character(len=*), intent(in) :: text private  subroutine write_track_size (self) Must be called when the track is finished. It writes its size at the\nmemorized position in the track header. Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self private  subroutine write_variable_length_quantity (self, i) Writes the integer i in the MIDI file\nusing the variable length quantity representation: Arguments Type Intent Optional Attributes Name class( MIDI_file ), intent(inout) :: self integer(kind=int32), intent(in) :: i","tags":"","loc":"module/midi_file_class.html"},{"title":"MIDI_control_changes – ForMIDI","text":"MIDI 1.0 Control Change Messages and Registered Parameter Numbers (RPNs) Used by module~~midi_control_changes~~UsedByGraph module~midi_control_changes MIDI_control_changes program~blues blues program~blues->module~midi_control_changes program~canon canon program~canon->module~midi_control_changes program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~midi_control_changes program~la_folia la_folia program~la_folia->module~midi_control_changes Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: All_Notes_Off = 123 integer, public, parameter :: All_Sound_Off = 120 integer, public, parameter :: Balance = 8 integer, public, parameter :: Balance_LSB = 40 integer, public, parameter :: Bank_Select = 0 integer, public, parameter :: Bank_Select_LSB = 32 integer, public, parameter :: Breath_Controller = 2 integer, public, parameter :: Breath_Controller_LSB = 34 integer, public, parameter :: Channel_Volume = 7 integer, public, parameter :: Channel_Volume_LSB = 39 integer, public, parameter :: Damper_Pedal_on_off = 64 integer, public, parameter :: Data_Decrement = 97 integer, public, parameter :: Data_Entry_MSB = 6 integer, public, parameter :: Data_Entry_MSB_LSB = 38 integer, public, parameter :: Data_Increment = 96 integer, public, parameter :: Effect_Control_1 = 12 integer, public, parameter :: Effect_Control_1_LSB = 44 integer, public, parameter :: Effect_Control_2 = 13 integer, public, parameter :: Effect_Control_2_LSB = 45 integer, public, parameter :: Effects_1_Depth = 91 integer, public, parameter :: Effects_2_Depth = 92 integer, public, parameter :: Effects_3_Depth = 93 integer, public, parameter :: Effects_4_Depth = 94 integer, public, parameter :: Effects_5_Depth = 95 integer, public, parameter :: Expression_Controller = 11 integer, public, parameter :: Expression_Controller_LSB = 43 integer, public, parameter :: Foot_Controller = 4 integer, public, parameter :: Foot_Controller_LSB = 36 integer, public, parameter :: General_Purpose_Controller_1 = 16 integer, public, parameter :: General_Purpose_Controller_1_LSB = 48 integer, public, parameter :: General_Purpose_Controller_2 = 17 integer, public, parameter :: General_Purpose_Controller_2_LSB = 49 integer, public, parameter :: General_Purpose_Controller_3 = 18 integer, public, parameter :: General_Purpose_Controller_3_LSB = 50 integer, public, parameter :: General_Purpose_Controller_4 = 19 integer, public, parameter :: General_Purpose_Controller_4_LSB = 51 integer, public, parameter :: General_Purpose_Controller_5 = 80 integer, public, parameter :: General_Purpose_Controller_6 = 81 integer, public, parameter :: General_Purpose_Controller_7 = 82 integer, public, parameter :: General_Purpose_Controller_8 = 83 integer, public, parameter :: High_Resolution_Velocity_Prefix = 88 integer, public, parameter :: Hold_2 = 69 integer, public, parameter :: Legato_Footswitch = 68 integer, public, parameter :: Local_Control_On_Off = 122 integer, public, parameter :: Modulation_Wheel_or_Lever = 1 integer, public, parameter :: Modulation_Wheel_or_Lever_LSB = 33 integer, public, parameter :: Mono_Mode_On = 126 integer, public, parameter :: Non_Registered_Parameter_Number_LSB = 98 integer, public, parameter :: Non_Registered_Parameter_Number_MSB = 99 integer, public, parameter :: Omni_Mode_Off = 124 integer, public, parameter :: Omni_Mode_On = 125 integer, public, parameter :: Pan = 10 integer, public, parameter :: Pan_LSB = 42 integer, public, parameter :: Poly_Mode_On = 127 integer, public, parameter :: Portamento_Control = 84 integer, public, parameter :: Portamento_On_Off = 65 integer, public, parameter :: Portamento_Time = 5 integer, public, parameter :: Portamento_Time_LSB = 37 integer, public, parameter :: Registered_Parameter_Number_LSB = 100 integer, public, parameter :: Registered_Parameter_Number_MSB = 101 integer, public, parameter :: Reset_All_Controllers = 121 integer, public, parameter :: Soft_Pedal_On_Off = 67 integer, public, parameter :: Sostenuto_On_Off = 66 integer, public, parameter :: Sound_Controller_1 = 70 integer, public, parameter :: Sound_Controller_10 = 79 integer, public, parameter :: Sound_Controller_2 = 71 integer, public, parameter :: Sound_Controller_3 = 72 integer, public, parameter :: Sound_Controller_4 = 73 integer, public, parameter :: Sound_Controller_5 = 74 integer, public, parameter :: Sound_Controller_6 = 75 integer, public, parameter :: Sound_Controller_7 = 76 integer, public, parameter :: Sound_Controller_8 = 77 integer, public, parameter :: Sound_Controller_9 = 78","tags":"","loc":"module/midi_control_changes.html"},{"title":"GM_instruments – ForMIDI","text":"Contains the list of General MIDI 128 instruments and 47 percussions Used by module~~gm_instruments~~UsedByGraph module~gm_instruments GM_instruments program~blues blues program~blues->module~gm_instruments program~canon canon program~canon->module~gm_instruments program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~gm_instruments program~la_folia la_folia program~la_folia->module~gm_instruments program~third_kind third_kind program~third_kind->module~gm_instruments Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: Accordion = 21 integer, public, parameter :: Acoustic_Bass = 32 integer, public, parameter :: Acoustic_Bass_Drum = 35 Percussive instruments (channel 9). This  list is required by the GM standard,\nbut more may be available: integer, public, parameter :: Acoustic_Grand_Piano = 0 GM instruments, grouped by family: integer, public, parameter :: Acoustic_Guitar_nylon = 24 integer, public, parameter :: Acoustic_Guitar_steel = 25 integer, public, parameter :: Acoustic_Snare = 38 integer, public, parameter :: Agogo = 113 integer, public, parameter :: Alto_Sax = 65 integer, public, parameter :: Applause = 126 integer, public, parameter :: Bag_pipe = 109 integer, public, parameter :: Banjo = 105 integer, public, parameter :: Baritone_Sax = 67 integer, public, parameter :: Bass_Drum_1 = 36 integer, public, parameter :: Bassoon = 70 integer, public, parameter :: Bird_Tweet = 123 integer, public, parameter :: Blown_Bottle = 76 integer, public, parameter :: Brass_Section = 61 integer, public, parameter :: Breath_Noise = 121 integer, public, parameter :: Bright_Acoustic_Piano = 1 integer, public, parameter :: Cabasa = 69 integer, public, parameter :: Celesta = 8 integer, public, parameter :: Cello = 42 integer, public, parameter :: Chinese_Cymbal = 52 integer, public, parameter :: Choir_Aahs = 52 integer, public, parameter :: Church_Organ = 19 integer, public, parameter :: Clarinet = 71 integer, public, parameter :: Claves = 75 integer, public, parameter :: Clavi = 7 integer, public, parameter :: Closed_Hi_Hat = 42 integer, public, parameter :: Contrabass = 43 integer, public, parameter :: Cowbell = 56 integer, public, parameter :: Crash_Cymbal_1 = 49 integer, public, parameter :: Crash_Cymbal_2 = 57 integer, public, parameter :: Distortion_Guitar = 30 integer, public, parameter :: Drawbar_Organ = 16 integer, public, parameter :: Dulcimer = 15 integer, public, parameter :: Electric_Bass_finger = 33 integer, public, parameter :: Electric_Bass_pick = 34 integer, public, parameter :: Electric_Grand_Piano = 2 integer, public, parameter :: Electric_Guitar_clean = 27 integer, public, parameter :: Electric_Guitar_jazz = 26 integer, public, parameter :: Electric_Guitar_muted = 28 integer, public, parameter :: Electric_Piano_1 = 4 integer, public, parameter :: Electric_Piano_2 = 5 integer, public, parameter :: Electric_Snare = 40 integer, public, parameter :: English_Horn = 69 integer, public, parameter :: FX_1_rain = 96 integer, public, parameter :: FX_2_soundtrack = 97 integer, public, parameter :: FX_3_crystal = 98 integer, public, parameter :: FX_4_atmosphere = 99 integer, public, parameter :: FX_5_brightness = 100 integer, public, parameter :: FX_6_goblins = 101 integer, public, parameter :: FX_7_echoes = 102 integer, public, parameter :: FX_8_sci_fi = 103 integer, public, parameter :: Fiddle = 110 integer, public, parameter :: Flute = 73 integer, public, parameter :: French_Horn = 60 integer, public, parameter :: Fretless_Bass = 35 integer, public, parameter :: Glockenspiel = 9 integer, public, parameter :: Guitar_Fret_Noise = 120 integer, public, parameter :: Guitar_harmonics = 31 integer, public, parameter :: Gunshot = 127 integer, public, parameter :: Hand_Clap = 39 integer, public, parameter :: Harmonica = 22 integer, public, parameter :: Harpsichord = 6 integer, public, parameter :: Helicopter = 125 integer, public, parameter :: Hi_Bongo = 60 integer, public, parameter :: Hi_Mid_Tom = 48 integer, public, parameter :: Hi_Wood_Block = 76 integer, public, parameter :: High_Agogo = 67 integer, public, parameter :: High_Floor_Tom = 43 integer, public, parameter :: High_Timbale = 65 integer, public, parameter :: High_Tom = 50 integer, public, parameter :: Honky_tonk_Piano = 3 integer, public, parameter :: Kalimba = 108 integer, public, parameter :: Koto = 107 integer, public, parameter :: Lead_1_square = 80 integer, public, parameter :: Lead_2_sawtooth = 81 integer, public, parameter :: Lead_3_calliope = 82 integer, public, parameter :: Lead_4_chiff = 83 integer, public, parameter :: Lead_5_charang = 84 integer, public, parameter :: Lead_6_voice = 85 integer, public, parameter :: Lead_7_fifths = 86 integer, public, parameter :: Lead_8_bass_lead = 87 integer, public, parameter :: Long_Guiro = 74 integer, public, parameter :: Long_Whistle = 72 integer, public, parameter :: Low_Agogo = 68 integer, public, parameter :: Low_Bongo = 61 integer, public, parameter :: Low_Conga = 64 integer, public, parameter :: Low_Floor_Tom = 41 integer, public, parameter :: Low_Mid_Tom = 47 integer, public, parameter :: Low_Timbale = 66 integer, public, parameter :: Low_Tom = 45 integer, public, parameter :: Low_Wood_Block = 77 integer, public, parameter :: Maracas = 70 integer, public, parameter :: Marimba = 12 integer, public, parameter :: Melodic_Tom = 117 integer, public, parameter :: Music_Box = 10 integer, public, parameter :: Mute_Cuica = 78 integer, public, parameter :: Mute_Hi_Conga = 62 integer, public, parameter :: Mute_Triangle = 80 integer, public, parameter :: Muted_Trumpet = 59 integer, public, parameter :: Oboe = 68 integer, public, parameter :: Ocarina = 79 integer, public, parameter :: Open_Cuica = 79 integer, public, parameter :: Open_Hi_Conga = 63 integer, public, parameter :: Open_Hi_Hat = 46 integer, public, parameter :: Open_Triangle = 81 integer, public, parameter :: Orchestra_Hit = 55 integer, public, parameter :: Orchestral_Harp = 46 integer, public, parameter :: Overdriven_Guitar = 29 integer, public, parameter :: Pad_1_new_age = 88 integer, public, parameter :: Pad_2_warm = 89 integer, public, parameter :: Pad_3_polysynth = 90 integer, public, parameter :: Pad_4_choir = 91 integer, public, parameter :: Pad_5_bowed = 92 integer, public, parameter :: Pad_6_metallic = 93 integer, public, parameter :: Pad_7_halo = 94 integer, public, parameter :: Pad_8_sweep = 95 integer, public, parameter :: Pan_Flute = 75 integer, public, parameter :: Pedal_Hi_Hat = 44 integer, public, parameter :: Percussive_Organ = 17 integer, public, parameter :: Piccolo = 72 integer, public, parameter :: Pizzicato_Strings = 45 integer, public, parameter :: Recorder = 74 integer, public, parameter :: Reed_Organ = 20 integer, public, parameter :: Reverse_Cymbal = 119 integer, public, parameter :: Ride_Bell = 53 integer, public, parameter :: Ride_Cymbal_1 = 51 integer, public, parameter :: Ride_Cymbal_2 = 59 integer, public, parameter :: Rock_Organ = 18 integer, public, parameter :: Seashore = 122 integer, public, parameter :: Shakuhachi = 77 integer, public, parameter :: Shamisen = 106 integer, public, parameter :: Shanai = 111 integer, public, parameter :: Short_Guiro = 73 integer, public, parameter :: Short_Whistle = 71 integer, public, parameter :: Side_Stick = 37 integer, public, parameter :: Sitar = 104 integer, public, parameter :: Slap_Bass_1 = 36 integer, public, parameter :: Slap_Bass_2 = 37 integer, public, parameter :: Soprano_Sax = 64 integer, public, parameter :: Splash_Cymbal = 55 integer, public, parameter :: Steel_Drums = 114 integer, public, parameter :: String_Ensemble_1 = 48 integer, public, parameter :: String_Ensemble_2 = 49 integer, public, parameter :: SynthBrass_1 = 62 integer, public, parameter :: SynthBrass_2 = 63 integer, public, parameter :: SynthStrings_1 = 50 integer, public, parameter :: SynthStrings_2 = 51 integer, public, parameter :: Synth_Bass_1 = 38 integer, public, parameter :: Synth_Bass_2 = 39 integer, public, parameter :: Synth_Drum = 118 integer, public, parameter :: Synth_Voice = 54 integer, public, parameter :: Taiko_Drum = 116 integer, public, parameter :: Tambourine = 54 integer, public, parameter :: Tango_Accordion = 23 integer, public, parameter :: Telephone_Ring = 124 integer, public, parameter :: Tenor_Sax = 66 integer, public, parameter :: Timpani = 47 integer, public, parameter :: Tinkle_Bell = 112 integer, public, parameter :: Tremolo_Strings = 44 integer, public, parameter :: Trombone = 57 integer, public, parameter :: Trumpet = 56 integer, public, parameter :: Tuba = 58 integer, public, parameter :: Tubular_Bells = 14 integer, public, parameter :: Vibraphone = 11 integer, public, parameter :: Vibraslap = 58 integer, public, parameter :: Viola = 41 integer, public, parameter :: Violin = 40 integer, public, parameter :: Voice_Oohs = 53 integer, public, parameter :: Whistle = 78 integer, public, parameter :: Woodblock = 115 integer, public, parameter :: Xylophone = 13","tags":"","loc":"module/gm_instruments.html"},{"title":"utilities – ForMIDI","text":"Functions to check the bounds of int8, int16, int32 values. Uses iso_fortran_env module~~utilities~~UsesGraph module~utilities utilities iso_fortran_env iso_fortran_env module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~utilities~~UsedByGraph module~utilities utilities module~midi_file_class MIDI_file_class module~midi_file_class->module~utilities module~music music module~music->module~utilities program~blues blues program~blues->module~midi_file_class program~blues->module~music program~canon canon program~canon->module~midi_file_class program~canon->module~music program~circle_of_fifths circle_of_fifths program~circle_of_fifths->module~midi_file_class program~circle_of_fifths->module~music program~la_folia la_folia program~la_folia->module~midi_file_class program~la_folia->module~music program~third_kind third_kind program~third_kind->module~midi_file_class program~third_kind->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function checked_int16 (i) result(i16) Receives a default kind integer, checks its bounds (Fortran signed int),\nfixes it if needed, and returns an int16: Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer(kind=int16) public  function checked_int32 (i) result(i32) Receives a default kind integer, checks its bounds (Fortran signed int),\nfixes it if needed, and returns an int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer(kind=int32) public  function checked_int8 (i, upper) result(i8) Receives a default kind integer, checks its MIDI bounds (15 or 127),\nfixes it if needed, and returns an int8: Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in), optional :: upper Return Value integer(kind=int8)","tags":"","loc":"module/utilities.html"},{"title":"circle_of_fifths – ForMIDI","text":"Uses iso_fortran_env MIDI_file_class GM_instruments MIDI_control_changes music program~~circle_of_fifths~~UsesGraph program~circle_of_fifths circle_of_fifths iso_fortran_env iso_fortran_env program~circle_of_fifths->iso_fortran_env module~gm_instruments GM_instruments program~circle_of_fifths->module~gm_instruments module~midi_control_changes MIDI_control_changes program~circle_of_fifths->module~midi_control_changes module~midi_file_class MIDI_file_class program~circle_of_fifths->module~midi_file_class module~music music program~circle_of_fifths->module~music module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A random walk on the circle of fifths Calls program~~circle_of_fifths~~CallsGraph program~circle_of_fifths circle_of_fifths proc~control_change MIDI_file%Control_Change program~circle_of_fifths->proc~control_change proc~end_of_track MIDI_file%end_of_track program~circle_of_fifths->proc~end_of_track proc~get_name MIDI_file%get_name program~circle_of_fifths->proc~get_name proc~midi_note MIDI_Note program~circle_of_fifths->proc~midi_note proc~new MIDI_file%new program~circle_of_fifths->proc~new proc~play_chord MIDI_file%play_chord program~circle_of_fifths->proc~play_chord proc~program_change MIDI_file%Program_Change program~circle_of_fifths->proc~program_change proc~track_header MIDI_file%track_header program~circle_of_fifths->proc~track_header proc~checked_int8 checked_int8 proc~control_change->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~control_change->proc~delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~new->proc~end_of_track proc~new->proc~track_header proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~checked_int32 checked_int32 proc~new->proc~checked_int32 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~play_chord->proc~checked_int32 proc~play_chord->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_chord->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_chord->proc~note_on proc~program_change->proc~checked_int8 proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~sequence_track_name->proc~write_string proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~set_time_signature->proc~delta_time proc~text_event->proc~write_string proc~write_string->proc~checked_int8 proc~write_string->proc~delta_time proc~write_string->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: channel integer :: i integer :: instrument integer, parameter :: length = 200 logical :: major type( MIDI_file ) :: midi character(len=3) :: name integer :: note real(kind=dp) :: p integer :: velocity Source Code program circle_of_fifths use , intrinsic :: iso_fortran_env , only : dp => real64 use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi integer :: channel , instrument , velocity , note character ( 3 ) :: name logical :: major integer , parameter :: length = 200 integer :: i real ( dp ) :: p ! Create a file with 2 tracks (including the metadata track): ! The first track is always a metadata track. We define the ! tempo: a quarter note will last 500000 µs = 0.5 s => tempo = 120 bpm call midi % new ( \"circle_of_fifths.mid\" , format = 1 , tracks = 2 , divisions = quarter_note , tempo = 500000 ) ! (1) The single music track: call midi % track_header () ! Sounds also good with instruments String_Ensemble_2 and Pad_8_sweep: instrument = Choir_Aahs ! We will use altenatively MIDI channels 0 and 1 to avoid cutting ! the tail of each chord: call midi % Program_Change ( channel = 0 , instrument = instrument ) call midi % Program_Change ( channel = 1 , instrument = instrument ) ! Heavy (127) reverb effect: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 127 ) ! Reverb call midi % Control_Change ( channel = 1 , type = Effects_1_Depth , ctl_value = 127 ) ! Reverb ! We start with C Major (note at the top of the Major circle): note = 1 major = . true . name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( note )) // \"4\" call midi % play_chord ( channel = 0 , note = MIDI_Note ( name ), chord = MAJOR_CHORD , velocity = f_level + 10 , value = whole_note ) ! A random walk with three events: we can go one note clockwise, ! one note counterclockwise or switch Major<->minor. do i = 1 , length ! A random number 0 <= p < 3 call random_number ( p ) p = 3 * p ! The three possible events: if ( p >= 2.0_dp ) then note = note + 1 if ( note > 12 ) note = 1 else if ( p >= 1.0_dp ) then note = note - 1 if ( note < 1 ) note = 12 else major = . not . major end if ! Alternate between channels 0 and 1: channel = mod ( i , 2 ) ! The volume will evolve, to obtain some dynamics: velocity = f_level + 10 + int ( 20 * sin ( real ( i ))) ! Write a major or minor chord on the track: if ( major ) then name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( note )) // \"4\" call midi % play_chord ( channel , MIDI_Note ( name ), MAJOR_CHORD , velocity , whole_note ) else name = trim ( CIRCLE_OF_FIFTHS_MINOR ( note )) // \"4\" call midi % play_chord ( channel , MIDI_Note ( name ), MINOR_CHORD , velocity , whole_note ) end if end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program circle_of_fifths","tags":"","loc":"program/circle_of_fifths.html"},{"title":"third_kind – ForMIDI","text":"Uses music MIDI_file_class GM_instruments program~~third_kind~~UsesGraph program~third_kind third_kind module~gm_instruments GM_instruments program~third_kind->module~gm_instruments module~midi_file_class MIDI_file_class program~third_kind->module~midi_file_class module~music music program~third_kind->module~music iso_fortran_env iso_fortran_env module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This is your starting point in the ForMIDI world.\nClose Encounters of the Third Kind: https://www.youtube.com/watch?v=S4PYI6TzqYk You will generally use the format SMF 1 which allows several tracks\nto be played together.\nWe will use only one musical track but we need 2 tracks, as there is\nalways a metadata track automatically created by the new() method.\nDivisions is the number of ticks (\"metrical timing\" MIDI scheme) in\na quarter note, and can be considered as the time resolution of your file. The MIDI velocity is the speed at which you type on the keyboard and\ncan be considered equivalent to the volume. As many MIDI values, it is\ndefined in the 0..127 range.\nThere are 16 channels (0..15).\nThe value (duration) of a note is expressed in MIDI ticks. Calls program~~third_kind~~CallsGraph program~third_kind third_kind proc~end_of_track MIDI_file%end_of_track program~third_kind->proc~end_of_track proc~get_name MIDI_file%get_name program~third_kind->proc~get_name proc~midi_note MIDI_Note program~third_kind->proc~midi_note proc~new MIDI_file%new program~third_kind->proc~new proc~play_note MIDI_file%play_note program~third_kind->proc~play_note proc~program_change MIDI_file%Program_Change program~third_kind->proc~program_change proc~track_header MIDI_file%track_header program~third_kind->proc~track_header proc~delta_time MIDI_file%delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~new->proc~end_of_track proc~new->proc~track_header proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~checked_int32 checked_int32 proc~new->proc~checked_int32 proc~checked_int8 checked_int8 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~play_note->proc~checked_int32 proc~play_note->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_note->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_note->proc~note_on proc~program_change->proc~checked_int8 proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~sequence_track_name->proc~write_string proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~set_time_signature->proc~delta_time proc~text_event->proc~write_string proc~write_string->proc~checked_int8 proc~write_string->proc~delta_time proc~write_string->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( MIDI_file ) :: midi Source Code program third_kind ! The main class you need to create music: use MIDI_file_class ! The function MIDI_Note() returns the MIDI number of a note from 12 (C0) ! to 127 (G9). The A4 (440 Hz tuning standard) is the note 69. use music ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi !> You will generally use the format SMF 1 which allows several tracks !> to be played together. !> We will use only one musical track but we need 2 tracks, as there is !> always a metadata track automatically created by the new() method. !> Divisions is the number of ticks (\"metrical timing\" MIDI scheme) in !> a quarter note, and can be considered as the time resolution of your file. ! We define the tempo: a quarter note will last 500000 µs = 0.5 s => tempo=120 bpm call midi % new ( \"third_kind.mid\" , format = 1 , tracks = 2 , divisions = quarter_note , tempo = 500000 , & & text_event = \"This file was created with the ForMIDI Fortran project\" ) ! (1) The single musical track: call midi % track_header () ! Choosing the instrument (in the 0..127 range): call midi % Program_Change ( channel = 0 , instrument = Pad_6_metallic ) ! Playing a sequence of five notes on MIDI channel 0: call midi % play_note ( channel = 0 , note = MIDI_Note ( \"G4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"A4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"F4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"F3\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"C4\" ), velocity = mf_level , value = half_note ) !> The MIDI velocity is the speed at which you type on the keyboard and !> can be considered equivalent to the volume. As many MIDI values, it is !> defined in the 0..127 range. !> There are 16 channels (0..15). !> The value (duration) of a note is expressed in MIDI ticks. call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program third_kind","tags":"","loc":"program/third_kind.html"},{"title":"canon – ForMIDI","text":"Uses music MIDI_file_class MIDI_control_changes GM_instruments program~~canon~~UsesGraph program~canon canon module~gm_instruments GM_instruments program~canon->module~gm_instruments module~midi_control_changes MIDI_control_changes program~canon->module~midi_control_changes module~midi_file_class MIDI_file_class program~canon->module~midi_file_class module~music music program~canon->module~music iso_fortran_env iso_fortran_env module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. An example based on the first measures of Pachelbel's Canon\nhttps://en.wikipedia.org/wiki/Pachelbel%27s_Canon Calls program~~canon~~CallsGraph program~canon canon proc~control_change MIDI_file%Control_Change program~canon->proc~control_change proc~end_of_track MIDI_file%end_of_track program~canon->proc~end_of_track proc~get_name MIDI_file%get_name program~canon->proc~get_name proc~midi_note MIDI_Note program~canon->proc~midi_note proc~new MIDI_file%new program~canon->proc~new proc~play_note MIDI_file%play_note program~canon->proc~play_note proc~program_change MIDI_file%Program_Change program~canon->proc~program_change proc~track_header MIDI_file%track_header program~canon->proc~track_header proc~checked_int8 checked_int8 proc~control_change->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~control_change->proc~delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~new->proc~end_of_track proc~new->proc~track_header proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~checked_int32 checked_int32 proc~new->proc~checked_int32 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~play_note->proc~checked_int32 proc~play_note->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_note->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_note->proc~note_on proc~program_change->proc~checked_int8 proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~sequence_track_name->proc~write_string proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~set_time_signature->proc~delta_time proc~text_event->proc~write_string proc~write_string->proc~checked_int8 proc~write_string->proc~delta_time proc~write_string->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial character(len=3), parameter :: bass (1:8) = [\"D3 \", \"A2 \", \"B2 \", \"F#2\", \"G2 \", \"D2 \", \"G2 \", \"A2 \"] integer :: i integer, parameter :: instrument (1:17) = [40, 41, 42, 44, 45, 48, 49, 51, 52, 89, 90, 91, 92, 94, 95, 99, 100] integer :: j type( MIDI_file ) :: midi integer, parameter :: panning (2:5) = [54, 34, 74, 94] character(len=3), parameter :: theme (1:16) = [\"F#5\", \"E5 \", \"D5 \", \"C#5\", \"B4 \", \"A4 \", \"B4 \", \"C#5\", \"D5 \", \"C#5\", \"B4 \", \"A4 \", \"G4 \", \"F#4\", \"G4 \", \"E4 \"] integer :: track character(len=13) :: track_name Source Code program canon use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi ! Notes of the bass and theme: character ( 3 ), parameter :: bass ( 1 : 8 ) = [ \"D3 \" , \"A2 \" , \"B2 \" , \"F#2\" , \"G2 \" , & & \"D2 \" , \"G2 \" , \"A2 \" ] character ( 3 ), parameter :: theme ( 1 : 16 ) = [ \"F#5\" , \"E5 \" , \"D5 \" , \"C#5\" , & & \"B4 \" , \"A4 \" , \"B4 \" , \"C#5\" , & & \"D5 \" , \"C#5\" , \"B4 \" , \"A4 \" , & & \"G4 \" , \"F#4\" , \"G4 \" , \"E4 \" ] ! List of General MIDI instruments to use sequentially: integer , parameter :: instrument ( 1 : 17 ) = [ 40 , 41 , 42 , 44 , 45 , 48 ,& & 49 , 51 , 52 , 89 , 90 , 91 , 92 , 94 , 95 , 99 , 100 ] ! Pan value for each track: integer , parameter :: panning ( 2 : 5 ) = [ 54 , 34 , 74 , 94 ] integer :: track character ( 13 ) :: track_name integer :: i , j ! Create a file with 5 tracks (including the metadata track): ! A quarter note will last 1000000 µs = 1 s => tempo = 60 bpm call midi % new ( \"canon.mid\" , format = 1 , tracks = 5 , divisions = quarter_note , tempo = 1000000 , copyright = \"Public domain\" ) ! (1) A first music track: ground bass call midi % track_header ( track_name = \"ground bass\" ) call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Reverb ! Instrument on channel 0: call midi % Program_Change ( channel = 0 , instrument = String_Ensemble_1 ) ! Panning: call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = panning ( 2 )) do j = 1 , 30 do i = 1 , 8 call midi % play_note ( channel = 0 , note = MIDI_Note ( bass ( i )), velocity = mf_level , value = quarter_note ) end do end do call midi % end_of_track () ! Three other music tracks: a three voices canon with various instruments do track = 3 , 5 write ( track_name , '(\"Canon voice \",I0)' ) track - 2 call midi % track_header ( track_name ) ! Reverb and pan: call midi % Control_Change ( channel = track , type = Effects_1_Depth , ctl_value = 64 ) call midi % Control_Change ( channel = track , type = Pan , ctl_value = panning ( track )) ! A pause to shift the start of each voice of the canon: call midi % play_note ( channel = track , note = 0 , velocity = 0 , value = 8 * quarter_note * ( track - 2 )) do j = 1 , 15 ! Let's change regularly the instruments to add some variations: call midi % Program_Change ( channel = track , instrument = instrument (( track - 3 ) + j )) ! Let's play the theme: do i = 1 , 16 call midi % play_note ( channel = track , note = MIDI_Note ( theme ( i )), velocity = mf_level , value = quarter_note ) end do end do call midi % end_of_track () end do call midi % close () print * , \"You can now play the file \" , midi % get_name () end program canon","tags":"","loc":"program/canon.html"},{"title":"blues – ForMIDI","text":"Uses iso_fortran_env MIDI_file_class GM_instruments MIDI_control_changes music program~~blues~~UsesGraph program~blues blues iso_fortran_env iso_fortran_env program~blues->iso_fortran_env module~gm_instruments GM_instruments program~blues->module~gm_instruments module~midi_control_changes MIDI_control_changes program~blues->module~midi_control_changes module~midi_file_class MIDI_file_class program~blues->module~midi_file_class module~music music program~blues->module~music module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A stochastic blues Calls program~~blues~~CallsGraph program~blues blues proc~control_change MIDI_file%Control_Change program~blues->proc~control_change proc~delta_time MIDI_file%delta_time program~blues->proc~delta_time proc~end_of_track MIDI_file%end_of_track program~blues->proc~end_of_track proc~get_name MIDI_file%get_name program~blues->proc~get_name proc~midi_note MIDI_Note program~blues->proc~midi_note proc~new MIDI_file%new program~blues->proc~new proc~note_off MIDI_file%Note_OFF program~blues->proc~note_off proc~note_on MIDI_file%Note_ON program~blues->proc~note_on proc~play_chord MIDI_file%play_chord program~blues->proc~play_chord proc~program_change MIDI_file%Program_Change program~blues->proc~program_change proc~track_header MIDI_file%track_header program~blues->proc~track_header proc~control_change->proc~delta_time proc~checked_int8 checked_int8 proc~control_change->proc~checked_int8 proc~checked_int32 checked_int32 proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~new->proc~end_of_track proc~new->proc~track_header proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~new->proc~checked_int32 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~play_chord->proc~delta_time proc~play_chord->proc~note_off proc~play_chord->proc~note_on proc~play_chord->proc~checked_int32 proc~program_change->proc~delta_time proc~program_change->proc~checked_int8 proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~sequence_track_name->proc~write_string proc~set_tempo->proc~delta_time proc~set_tempo->proc~checked_int32 proc~set_time_signature->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~text_event->proc~write_string proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity proc~write_string->proc~delta_time proc~write_string->proc~checked_int8 proc~write_string->proc~write_variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial logical :: again integer :: b_scale (0:127) real(kind=dp) :: delta integer :: i integer :: j integer :: jmax integer, parameter :: length = 200 type( MIDI_file ) :: midi integer, parameter :: nb_notes = 6 integer :: note integer :: octave real(kind=dp) :: p integer :: tonic integer :: value Source Code program blues use , intrinsic :: iso_fortran_env , only : dp => real64 use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Modulation_Wheel_or_Lever , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi real ( dp ) :: p , delta integer :: i , j , jmax integer , parameter :: nb_notes = 6 integer , parameter :: length = 200 integer :: b_scale ( 0 : 127 ) ! Blues scale integer :: octave , note , value logical :: again ! The tonic is the C note: integer :: tonic tonic = MIDI_Note ( \"C1\" ) ! Create a file with 3 tracks (including the metadata track): ! A quarter note will last 1000000 µs = 1 s => tempo = 60 bpm call midi % new ( \"blues.mid\" , format = 1 , tracks = 3 , divisions = quarter_note , tempo = 1000000 ) ! (1) A first music track with guitar: call midi % track_header () ! Reverb: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Modulation: call midi % Control_Change ( channel = 0 , type = Modulation_Wheel_or_Lever , ctl_value = 40 ) ! Panning, slightly on the left (center is 64): call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = 44 ) ! Instrument: call midi % Program_Change ( channel = 0 , instrument = Distortion_Guitar ) ! A blues scale C, Eb, F, Gb, G, Bb, repeated at each octave. ! The MIDI note 0 is a C-1, but can not be heard (f=8.18 Hz). ! https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale ! We copy the blues scale at the beginning of the array: do j = 0 , 5 b_scale ( j ) = MIDI_Note ( trim ( HEXATONIC_BLUES_SCALE ( j + 1 )) // \"0\" ) - 12 end do ! And we copy it as many times as possible: jmax = nb_notes - 1 octave = 1 again = . true . do do j = 0 , nb_notes - 1 if ( b_scale ( j ) + octave * 12 <= 127 ) then jmax = octave * nb_notes + j b_scale ( jmax ) = b_scale ( j ) + octave * 12 else again = . false . end if end do octave = octave + 1 if (. not . again ) exit end do ! Let's make a random walk on that scale: value = quarter_note note = tonic do i = 1 , length call midi % play_chord ( channel = 0 , note = b_scale ( note ), chord = POWER_CHORD , velocity = p_level - 2 , value = value ) ! Random walk: call random_number ( p ) ! We need a kind of restoring force to avoid going too far: delta = (( b_scale ( note ) - b_scale ( tonic )) / 1 2.0_dp ) * 0.45_dp if ( p >= 0.55_dp + delta ) then if ( note < jmax ) note = note + 1 else if ( p >= 0.1_dp ) then if ( note > 0 ) note = note - 1 end if ! Duration: call random_number ( p ) if ( p >= 0.75_dp ) then value = quarter_note else value = sixteenth_note end if end do call midi % end_of_track () ! (2) Drums track (channel 9 by default): call midi % track_header () ! Reverb: call midi % Control_Change ( channel = drums , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the right (center is 64): call midi % Control_Change ( channel = drums , type = Pan , ctl_value = 84 ) do i = 1 , length * 2 call midi % delta_time ( 0 ) ! On the drum channel, each note corresponds to a percussion: call midi % Note_ON ( channel = drums , note = Closed_Hi_Hat , velocity = 80 ) ! We use modulo to create a rhythm: if ( mod ( i , 6 ) == 4 ) then call midi % delta_time ( 0 ) call midi % Note_ON ( channel = drums , note = Acoustic_Snare , velocity = 92 ) else if (( mod ( i , 6 ) == 1 ) . or . ( mod ( i , 12 ) == 6 )) then call midi % delta_time ( 0 ) call midi % Note_ON ( channel = drums , note = Acoustic_Bass_Drum , velocity = 127 ) end if call midi % delta_time ( quarter_note / 3 ) call midi % Note_OFF ( channel = drums , note = Closed_Hi_Hat , velocity = 64 ) if ( mod ( i , 6 ) == 4 ) then call midi % delta_time ( 0 ) call midi % Note_OFF ( channel = drums , note = Acoustic_Snare , velocity = 92 ) else if (( mod ( i , 6 ) == 1 ) . or . ( mod ( i , 12 ) == 6 )) then call midi % delta_time ( 0 ) call midi % Note_OFF ( channel = drums , note = Acoustic_Bass_Drum , velocity = 127 ) end if end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program blues","tags":"","loc":"program/blues.html"},{"title":"la_folia – ForMIDI","text":"Uses music MIDI_file_class MIDI_control_changes GM_instruments program~~la_folia~~UsesGraph program~la_folia la_folia module~gm_instruments GM_instruments program~la_folia->module~gm_instruments module~midi_control_changes MIDI_control_changes program~la_folia->module~midi_control_changes module~midi_file_class MIDI_file_class program~la_folia->module~midi_file_class module~music music program~la_folia->module~music iso_fortran_env iso_fortran_env module~midi_file_class->iso_fortran_env module~utilities utilities module~midi_file_class->module~utilities module~music->iso_fortran_env module~music_common music_common module~music->module~music_common module~music->module~utilities module~utilities->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. An example on the classical Portuguese/Spanish theme of La Folia\nhttps://en.wikipedia.org/wiki/Folia Calls program~~la_folia~~CallsGraph program~la_folia la_folia proc~analyze analyze program~la_folia->proc~analyze proc~control_change MIDI_file%Control_Change program~la_folia->proc~control_change proc~dotted dotted program~la_folia->proc~dotted proc~end_of_track MIDI_file%end_of_track program~la_folia->proc~end_of_track proc~get_name MIDI_file%get_name program~la_folia->proc~get_name proc~midi_note MIDI_Note program~la_folia->proc~midi_note proc~new MIDI_file%new program~la_folia->proc~new proc~play_broken_chord MIDI_file%play_broken_chord program~la_folia->proc~play_broken_chord proc~play_chord MIDI_file%play_chord program~la_folia->proc~play_chord proc~program_change MIDI_file%Program_Change program~la_folia->proc~program_change proc~track_header MIDI_file%track_header program~la_folia->proc~track_header proc~checked_int8 checked_int8 proc~control_change->proc~checked_int8 proc~delta_time MIDI_file%delta_time proc~control_change->proc~delta_time proc~end_of_track->proc~delta_time proc~write_track_size MIDI_file%write_track_size proc~end_of_track->proc~write_track_size proc~new->proc~end_of_track proc~new->proc~track_header proc~checked_int16 checked_int16 proc~new->proc~checked_int16 proc~checked_int32 checked_int32 proc~new->proc~checked_int32 proc~new->proc~checked_int8 proc~copyright_notice MIDI_file%copyright_notice proc~new->proc~copyright_notice proc~init_formidi MIDI_file%init_formidi proc~new->proc~init_formidi proc~set_tempo MIDI_file%set_tempo proc~new->proc~set_tempo proc~set_time_signature MIDI_file%set_time_signature proc~new->proc~set_time_signature proc~text_event MIDI_file%text_event proc~new->proc~text_event proc~play_broken_chord->proc~checked_int32 proc~play_broken_chord->proc~delta_time proc~note_off MIDI_file%Note_OFF proc~play_broken_chord->proc~note_off proc~note_on MIDI_file%Note_ON proc~play_broken_chord->proc~note_on proc~play_chord->proc~checked_int32 proc~play_chord->proc~delta_time proc~play_chord->proc~note_off proc~play_chord->proc~note_on proc~program_change->proc~checked_int8 proc~program_change->proc~delta_time proc~sequence_track_name MIDI_file%sequence_track_name proc~track_header->proc~sequence_track_name proc~track_header->proc~text_event proc~write_string MIDI_file%write_string proc~copyright_notice->proc~write_string proc~delta_time->proc~checked_int32 proc~write_variable_length_quantity MIDI_file%write_variable_length_quantity proc~delta_time->proc~write_variable_length_quantity proc~note_off->proc~checked_int8 proc~note_on->proc~checked_int8 proc~sequence_track_name->proc~write_string proc~set_tempo->proc~checked_int32 proc~set_tempo->proc~delta_time proc~set_time_signature->proc~checked_int8 proc~set_time_signature->proc~delta_time proc~text_event->proc~write_string proc~write_string->proc~checked_int8 proc~write_string->proc~delta_time proc~write_string->proc~write_variable_length_quantity proc~variable_length_quantity variable_length_quantity proc~write_variable_length_quantity->proc~variable_length_quantity Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer, dimension(3) :: arpeggio1 integer, dimension(3) :: arpeggio2 character(len=3) :: chord_type character(len=7), parameter :: chords (1:17) = [\"D3 m h.\", \"A2 7 h.\", \"D3 m h.\", \"C3 M h.\", \"F3 M h.\", \"C3 M h.\", \"D3 m h.\", \"A2 7 h.\", \"D3 m h.\", \"A2 7 h.\", \"D3 m h.\", \"C3 M h.\", \"F3 M h.\", \"C3 M h.\", \"D3 m h.\", \"A2 7 h.\", \"D3 m h.\"] integer :: d integer :: i integer :: j type( MIDI_file ) :: midi integer :: n character(len=3) :: note character(len=3) :: note_value Subroutines subroutine analyze (string, note, chord_type, note_value) Receives a string with an encoded chords, and returns its fundamental,\nthe type of chord and its encoded value Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=3), intent(out) :: note character(len=3), intent(out) :: chord_type character(len=3), intent(out) :: note_value Source Code program la_folia use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi integer :: n , d character ( 3 ) :: note , chord_type , note_value integer , dimension ( 3 ) :: arpeggio1 , arpeggio2 ! Chords of the Folia theme in D minor. ! This is a first attempt to encode a chord into a string with its fundamental, ! its type (M, m, 7th...) and its value (w, q, h, etc.). ! That system may evolve in the future. ! https://en.wikipedia.org/wiki/Note_value character ( 7 ), parameter :: chords ( 1 : 17 ) = [ \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" , \"C3 M h.\" , & & \"F3 M h.\" , \"C3 M h.\" , \"D3 m h.\" , \"A2 7 h.\" , & & \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" , \"C3 M h.\" , & & \"F3 M h.\" , \"C3 M h.\" , \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" ] integer :: i , j ! Create a file with 3 tracks (including the metadata track): ! A quarter note will last 600000 µs = 0.6 s => tempo = 100 bpm ! The time signature is 3/4 (this argument is optional with 4/4 for default value). call midi % new ( \"la_folia.mid\" , format = 1 , tracks = 3 , divisions = quarter_note , tempo = 600000 , & & time_signature = [ 3 , 4 ], copyright = \"Public domain\" ) ! (1) A track with chords played by strings on MIDI channel 0 call midi % track_header ( track_name = \"chords\" ) ! Reverb: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the left (center is 64): call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = 44 ) ! Choosing the instrument: call midi % Program_Change ( channel = 0 , instrument = String_Ensemble_1 ) ! We repeat the theme three times identically: do j = 1 , 3 do i = 1 , 17 call analyze ( chords ( i ), note , chord_type , note_value ) if ( note_value ( 1 : 1 ) == \"q\" ) d = quarter_note ! quarter note if ( note_value ( 1 : 1 ) == \"h\" ) d = half_note ! half note if ( note_value ( 2 : 2 ) == \".\" ) d = dotted ( d ) ! Dotted note n = MIDI_Note ( trim ( note )) select case ( trim ( chord_type )) case ( \"m\" ) call midi % play_chord ( channel = 0 , note = n , chord = MINOR_CHORD , velocity = f_level , value = d ) case ( \"M\" ) call midi % play_chord ( channel = 0 , note = n , chord = MAJOR_CHORD , velocity = f_level , value = d ) case ( \"7\" ) call midi % play_chord ( channel = 0 , note = n , chord = DOMINANT_7TH_CHORD , velocity = f_level , value = d ) end select end do end do ! Outro: call midi % play_chord ( channel = 0 , note = n , chord = MINOR_CHORD , velocity = f_level , value = d ) call midi % end_of_track () ! (2) A track with arpeggios by plucked strings on MIDI channel 1 call midi % track_header ( track_name = \"la Folia\" ) ! Reverb: call midi % Control_Change ( channel = 1 , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the right (center is 64): call midi % Control_Change ( channel = 1 , type = Pan , ctl_value = 84 ) ! Choosing the instrument: call midi % Program_Change ( channel = 1 , instrument = Electric_Guitar_clean ) ! We repeat the theme three times but with various arpeggios: do j = 1 , 3 do i = 1 , 17 call analyze ( chords ( i ), note , chord_type , note_value ) if ( note_value ( 1 : 1 ) == \"q\" ) d = eighth_note if ( note_value ( 1 : 1 ) == \"h\" ) d = quarter_note if ( note_value ( 2 : 2 ) == \".\" ) d = dotted ( d ) n = MIDI_Note ( trim ( note )) select case ( trim ( chord_type )) case ( \"m\" ) arpeggio1 = MINOR_CHORD case ( \"M\" ) arpeggio1 = MAJOR_CHORD case ( \"7\" ) ! We don't play the fifth (7), because we want only three notes, not four: arpeggio1 = [ 0 , 4 , 10 ] end select ! Each chord is played two times, in various ways: select case ( j ) case ( 1 ) ! Swept the same way: arpeggio2 = arpeggio1 case ( 2 ) ! The second time, swept in reverse order: arpeggio2 = arpeggio1 ( 3 : 1 : - 1 ) case ( 3 ) ! Both reversed: arpeggio2 = arpeggio1 ( 3 : 1 : - 1 ) arpeggio1 = arpeggio2 end select call midi % play_broken_chord ( channel = 1 , note = n , chord = arpeggio1 , velocity = mf_level , value = d ) call midi % play_broken_chord ( channel = 1 , note = n , chord = arpeggio2 , velocity = mf_level , value = d ) end do end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () contains !> Receives a string with an encoded chords, and returns its fundamental, !> the type of chord and its encoded value subroutine analyze ( string , note , chord_type , note_value ) character ( * ), intent ( in ) :: string character ( 3 ), intent ( out ) :: note , chord_type , note_value integer :: i1 , i2 i1 = index ( trim ( string ), \" \" , back = . false .) i2 = index ( trim ( string ), \" \" , back = . true .) note = string ( 1 : i1 - 1 ) chord_type = string ( i1 + 1 : i2 - 1 ) note_value = string ( i2 + 1 :) end subroutine end program la_folia","tags":"","loc":"program/la_folia.html"},{"title":"music_common.f90 – ForMIDI","text":"Files dependent on this one sourcefile~~music_common.f90~~AfferentGraph sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90 music.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~music.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~music.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~music.f90 sourcefile~third_kind.f90 third_kind.f90 sourcefile~third_kind.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-09 ! Last modifications: 2024-05-09 !> Contains music theory elements: scales, circle of fifths, chords, etc. !> !> This file will be kept identical in the ForMIDI and ForSynth projects. !> It could be put in a separate fpm repository and used as a dependency, !> but for the time being, synchronizing it by hand is sufficient. module music_common implicit none public !> We define some scales, excluding the octave of the first note. !> Always use the trim() function to remove trailing spaces. !> https://en.wikipedia.org/wiki/Scale_(music) character ( 2 ), dimension ( 1 : 12 ), parameter :: CHROMATIC_SCALE = & & [ 'C ' , 'C#' , 'D ' , 'D#' , 'E ' , 'F ' , 'F#' , 'G ' , 'G#' , 'A ' , 'A#' , 'B ' ] !> https://en.wikipedia.org/wiki/Major_scale character ( 1 ), dimension ( 1 : 7 ), parameter :: MAJOR_SCALE = & & [ 'C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' ] !> https://en.wikipedia.org/wiki/Minor_scale#Harmonic_minor_scale character ( 2 ), dimension ( 1 : 7 ), parameter :: HARMONIC_MINOR_SCALE = & & [ 'A ' , 'B ' , 'C ' , 'D ' , 'E ' , 'F ' , 'G#' ] !> https://en.wikipedia.org/wiki/Pentatonic_scale#Major_pentatonic_scale character ( 1 ), dimension ( 1 : 5 ), parameter :: MAJOR_PENTATONIC_SCALE = & & [ 'C' , 'D' , 'E' , 'G' , 'A' ] !> https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale character ( 2 ), dimension ( 1 : 6 ), parameter :: HEXATONIC_BLUES_SCALE = & & [ 'C ' , 'Eb' , 'F ' , 'Gb' , 'G ' , 'Bb' ] !> https://en.wikipedia.org/wiki/Whole_tone_scale character ( 2 ), dimension ( 1 : 6 ), parameter :: WHOLE_TONE_SCALE = & & [ 'C ' , 'D ' , 'E ' , 'F#' , 'G#' , 'A#' ] !> https://en.wikipedia.org/wiki/Circle_of_fifths !> Always use the trim() function to remove trailing spaces. character ( 2 ), dimension ( 1 : 12 ) :: CIRCLE_OF_FIFTHS_MAJOR = & & [ 'C ' , 'G ' , 'D ' , 'A ' , 'E ' , 'B ' , 'Gb' , 'Db' , 'Ab' , 'Eb' , 'Bb' , 'F ' ] character ( 2 ), dimension ( 1 : 12 ) :: CIRCLE_OF_FIFTHS_MINOR = & & [ 'A ' , 'E ' , 'B ' , 'F#' , 'C#' , 'G#' , 'Eb' , 'Bb' , 'F ' , 'C ' , 'G ' , 'D ' ] !> Some frequent chords. !> These arrays can be passed to the write_chord() subroutine. !> https://en.wikipedia.org/wiki/Chord_(music) integer , parameter :: MAJOR_CHORD ( 1 : 3 ) = [ 0 , 4 , 7 ] integer , parameter :: MINOR_CHORD ( 1 : 3 ) = [ 0 , 3 , 7 ] integer , parameter :: DOMINANT_7TH_CHORD ( 1 : 4 ) = [ 0 , 4 , 7 , 10 ] integer , parameter :: SUS2_CHORD ( 1 : 3 ) = [ 0 , 2 , 7 ] integer , parameter :: SUS4_CHORD ( 1 : 3 ) = [ 0 , 5 , 7 ] integer , parameter :: POWER_CHORD ( 1 : 3 ) = [ 0 , 7 , 12 ] integer , private :: j ! Needed for the following implied do loop: integer , parameter :: CLUSTER_CHORD ( 1 : 12 ) = [( j , j = 0 , 11 )] contains end module music_common","tags":"","loc":"sourcefile/music_common.f90.html"},{"title":"music.f90 – ForMIDI","text":"This file depends on sourcefile~~music.f90~~EfferentGraph sourcefile~music.f90 music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~music.f90~~AfferentGraph sourcefile~music.f90 music.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~music.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~music.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~music.f90 sourcefile~third_kind.f90 third_kind.f90 sourcefile~third_kind.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-23 !> Offers music parameters and functions specific to MIDI files. module music use , intrinsic :: iso_fortran_env , only : int8 , error_unit ! Music theory elements common to the ForMIDI and ForSynth projects. ! We don't use \"only:\" to allow \"use music\" to include ! the whole \"music_common\" module: use music_common use utilities , only : checked_int8 implicit none public !> The timing resolution of a MIDI file is defined by the number !> of MIDI ticks in a quarter note: the value 96 is commonly used because !> it can be divided by 2 and 3. !> We also define the most useful other values. !> https://en.wikipedia.org/wiki/Note_value integer , parameter :: quarter_note = 96 integer , parameter :: whole_note = 4 * quarter_note integer , parameter :: half_note = 2 * quarter_note integer , parameter :: eighth_note = quarter_note / 2 ! Quaver integer , parameter :: sixteenth_note = quarter_note / 4 ! Semiquaver integer , parameter :: thirty_second_note = quarter_note / 8 !> Common note levels expressed as MIDI velocities !> https://arxiv.org/pdf/1705.05322 integer , parameter :: ffff_level = 127 integer , parameter :: fff_level = 112 integer , parameter :: ff_level = 96 integer , parameter :: f_level = 80 integer , parameter :: mf_level = 64 integer , parameter :: mp_level = 53 integer , parameter :: p_level = 42 integer , parameter :: pp_level = 31 integer , parameter :: ppp_level = 20 integer , parameter :: pppp_level = 8 contains !> Returns the MIDI note number, from 12 (C0) to 127 (G9). !> The note name is composed of two or three characters, !> for example \"A4\", \"A#4\", \"Ab4\", where the final character is !> the octave. integer function MIDI_Note ( note ) character ( * ), intent ( in ) :: note ! 0 <= octave <=9 integer :: octave ! Gap relative to A4 (note 69) in semitones: integer :: gap ! ASCII code of the 0 character: integer , parameter :: zero = iachar ( '0' ) select case ( note ( 1 : 1 )) case ( 'C' ) gap = - 9 case ( 'D' ) gap = - 7 case ( 'E' ) gap = - 5 case ( 'F' ) gap = - 4 case ( 'G' ) gap = - 2 case ( 'A' ) gap = 0 case ( 'B' ) gap = + 2 case default write ( error_unit , * ) \"ERROR 4: unknown note name!\" error stop 4 end select ! Treating accidentals (sharp, flat) and computing the octave: select case ( note ( 2 : 2 )) case ( 'b' ) gap = gap - 1 octave = iachar ( note ( 3 : 3 )) - zero case ( '#' ) gap = gap + 1 octave = iachar ( note ( 3 : 3 )) - zero case default octave = iachar ( note ( 2 : 2 )) - zero end select if (( octave >= 0 ) . and . ( octave <= 9 )) then gap = gap + ( octave - 4 ) * 12 else write ( error_unit , * ) \"ERROR 5: octave out of bounds [0; 9]\" error stop 5 end if ! Computing and returning the MIDI note number (A4 is 69): MIDI_Note = 69 + gap end function MIDI_Note !> Receives a MIDI note (for example 69), !> and returns the name of the note (for example A4). !> It works also with the octave -1, although most of its notes !> are too low for hearing. function note_name ( MIDI_note ) result ( name ) integer , intent ( in ) :: MIDI_note integer :: m character ( 2 ) :: octave character ( 4 ) :: name m = checked_int8 ( MIDI_note ) write ( octave , '(I0)' ) ( m / 12 ) - 1 name = trim ( CHROMATIC_SCALE ( mod ( m , 12 ) + 1 )) // octave end function !> Returns the value of a dotted note. integer function dotted ( value ) integer , intent ( in ) :: value dotted = value + value / 2 end function end module music","tags":"","loc":"sourcefile/music.f90.html"},{"title":"MIDI_file_class.f90 – ForMIDI","text":"This file depends on sourcefile~~midi_file_class.f90~~EfferentGraph sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~midi_file_class.f90~~AfferentGraph sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~midi_file_class.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~midi_file_class.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~midi_file_class.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~midi_file_class.f90 sourcefile~third_kind.f90 third_kind.f90 sourcefile~third_kind.f90->sourcefile~midi_file_class.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-22 !> Contains the main class you need to create a MIDI file. module MIDI_file_class use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , error_unit use utilities , only : checked_int8 , checked_int16 , checked_int32 implicit none !------------------------ !> Useful MIDI parameters !------------------------ !> Percussions channel (in the 0..15 range): integer , parameter :: drums = 9 !> Used by Note ON and Note OFF events: integer , parameter :: ON = 144 ! z'90' integer , parameter :: OFF = 128 ! z'80' !> The main class you need to create a MIDI file. type MIDI_file character ( len = :), private , allocatable :: filename ! Output unit and file status: integer , private :: unit integer , private :: status ! To store where to write the size of a track in the file: integer ( int32 ), private :: size_pos contains procedure , private :: init_formidi procedure , private :: write_variable_length_quantity procedure :: new procedure :: track_header procedure :: set_tempo procedure :: set_time_signature procedure :: end_of_track procedure :: get_name procedure , private :: write_track_size procedure :: Program_Change procedure :: play_note procedure :: play_chord procedure :: play_broken_chord procedure :: close procedure :: Control_Change procedure :: Note_ON procedure :: Note_OFF procedure :: delta_time procedure , private :: write_string procedure :: text_event procedure , private :: copyright_notice procedure :: sequence_track_name procedure :: instrument_name procedure :: lyric procedure :: marker procedure :: cue_point end type MIDI_file private public :: MIDI_file , drums , ON , OFF , variable_length_quantity contains !> Create a new MIDI file and its metadata track. !> Concerning the \"divisions\" argument, ForMIDI uses the \"metrical timing\" !> scheme, defining the number of ticks in a quarter note. The \"timecode\" !> scheme is not implemented. subroutine new ( self , file_name , format , tracks , divisions , tempo , time_signature , copyright , text_event ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: file_name integer , intent ( in ) :: format ! 8 bits integer , intent ( in ) :: tracks ! 16 bits integer , intent ( in ) :: divisions ! 32 bits integer , intent ( in ) :: tempo ! 32 bits integer , optional , intent ( in ) :: time_signature (:) character ( len =* ), optional , intent ( in ) :: copyright character ( len =* ), optional , intent ( in ) :: text_event integer ( int8 ) :: octets ( 0 : 13 ) integer ( int16 ) :: t integer ( int32 ) :: d call self % init_formidi () self % filename = file_name ! Header chunk: \"MThd\" octets ( 0 ) = int ( z '4d' , int8 ) octets ( 1 ) = int ( z '54' , int8 ) octets ( 2 ) = int ( z '68' , int8 ) octets ( 3 ) = int ( z '64' , int8 ) ! Remaining size of the header (6 bytes): octets ( 4 ) = int ( z '00' , int8 ) octets ( 5 ) = int ( z '00' , int8 ) octets ( 6 ) = int ( z '00' , int8 ) octets ( 7 ) = int ( z '06' , int8 ) !> SMF format: !> 0: only one track in the file !> 1: several tracks played together (generally used) !> 2: several tracks played sequentially if (( format == 0 ) . and . ( tracks > 1 )) then write ( error_unit , * ) \"ERROR 3: you can use only one track with SMF 0\" stop 3 end if octets ( 8 ) = 0 octets ( 9 ) = checked_int8 ( format ) ! Number of tracks (<=65535) t = checked_int16 ( tracks ) octets ( 10 ) = int ( ishft ( t , - 8 ), int8 ) octets ( 11 ) = int ( t , int8 ) ! MIDI ticks per quarter note (\"metrical timing\" scheme): d = checked_int32 ( divisions ) octets ( 12 ) = int ( ishft ( d , - 8 ), int8 ) octets ( 13 ) = int ( d , int8 ) open ( newunit = self % unit , file = file_name , access = 'stream' , status = 'replace' , & & action = 'write' , iostat = self % status ) write ( self % unit , iostat = self % status ) octets ! Starting with the metadata track: call self % track_header () if ( present ( copyright )) call self % copyright_notice ( copyright ) if ( present ( text_event )) call self % text_event ( text_event ) if (. not . present ( time_signature )) then ! Default values 4/4 and 24 MIDI clocks (a quarter note) for the metronome: call set_time_signature ( self , numerator = 4 , denominator = 4 , metronome = 24 ) else if ( size ( time_signature ) == 2 ) then ! The default metronome is 24 MIDI clocks (a quarter note): call set_time_signature ( self , numerator = time_signature ( 1 ), denominator = time_signature ( 2 ), metronome = 24 ) else call set_time_signature ( self , numerator = time_signature ( 1 ), denominator = time_signature ( 2 ), & & metronome = time_signature ( 3 )) end if end if call self % set_tempo ( checked_int32 ( tempo )) ! Closing the metadata track: call self % end_of_track () end subroutine !> Verifies the needed data types. subroutine init_formidi ( self ) class ( MIDI_file ), intent ( in ) :: self ! We need those kinds for writing MIDI files. if (( int8 < 0 ) . or . ( int16 < 0 ) . or . ( int32 < 0 )) then write ( error_unit , * ) \"ERROR 1: int8 and/or int16 and/or int32 not supported!\" error stop 1 end if end subroutine !> MIDI delta times are composed of one to four bytes, depending on their !> values. If there is still bytes to write, the MSB (most significant bit) !> of the current byte is 1, else 0. !> This functions is automatically tested. !> https://en.wikipedia.org/wiki/Variable-length_quantity pure function variable_length_quantity ( i ) result ( VLQ ) integer ( int32 ), intent ( in ) :: i integer ( int8 ), allocatable , dimension (:) :: VLQ integer ( int32 ) :: j , again ! A First In Last Out 4 bytes stack (or Last In First Out): integer ( int32 ) :: filo ! We use a variable j because i has intent(in): j = i filo = 0 ! The 7 least significant bits are placed in filo (0x7F = 0b01111111): filo = iand ( j , z '7F' ) ! They are now eliminated from j by shifting bits of j 7 places ! to the right (zeros are introduced on the left): j = ishft ( j , - 7 ) ! The same process is a applied until j is empty: do if ( j == 0 ) exit ! The bits already in filo are shifted 1 byte to the left ! (filo is Little Endian): filo = ishft ( filo , + 8 ) ! A byte of j with the most signicant bit set to 1 (0x80 = 0b10000000) ! can now be added on the right of filo: filo = filo + ior ( iand ( j , z '7F' ), z '80' ) ! Preparing next iteration: j = ishft ( j , - 7 ) end do ! Starting with a void array: allocate ( VLQ ( 0 )) ! The bytes accumulated in filo are now written in the VLQ array ! in the reverse order (MIDI files are Big Endian): do ! Appending the LSB of filo in the VLQ array: VLQ = [ VLQ , int ( filo , int8 ) ] ! Is the bit 8 a 1? (meaning there is still other bytes to read): again = iand ( filo , z '80' ) if ( again /= 0 ) then ! The written LSB can now be eliminated before next iteration: filo = ishft ( filo , - 8 ) else ! Nothing left to write: exit end if end do end function variable_length_quantity !> Writes the integer i in the MIDI file !> using the variable length quantity representation: subroutine write_variable_length_quantity ( self , i ) class ( MIDI_file ), intent ( inout ) :: self integer ( int32 ), intent ( in ) :: i integer ( int32 ) :: j integer ( int8 ), allocatable , dimension (:) :: array ! The maximum possible MIDI value: if ( i > int ( z '0FFFFFFF' , int32 )) then write ( error_unit , * ) \"ERROR 2: delay > 0x0FFFFFFF ! \" , i error stop 2 end if array = variable_length_quantity ( i ) ! The bytes are now written in the file: do j = 1 , size ( array ) write ( self % unit , iostat = self % status ) array ( j ) end do end subroutine write_variable_length_quantity !> Each MIDI event must be preceded by a delay called \"delta time\", !> expressed in MIDI ticks. subroutine delta_time ( self , ticks ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: ticks call self % write_variable_length_quantity ( checked_int32 ( ticks )) end subroutine !> Closes the MIDI file. subroutine close ( self ) class ( MIDI_file ), intent ( inout ) :: self close ( self % unit , iostat = self % status ) end subroutine !> Writes a track header and stores the position where the size of the !> track will be written when the track will be closed. subroutine track_header ( self , track_name , text_event ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), optional , intent ( in ) :: track_name character ( len =* ), optional , intent ( in ) :: text_event integer ( int8 ) :: octets ( 0 : 7 ) ! The chunk begin with \"MTrk\": octets ( 0 ) = int ( z '4d' , int8 ) octets ( 1 ) = int ( z '54' , int8 ) octets ( 2 ) = int ( z '72' , int8 ) octets ( 3 ) = int ( z '6b' , int8 ) write ( self % unit , iostat = self % status ) octets ( 0 : 3 ) ! Size of the data. Unknown for the moment. ! We memorize the position and will write the size when known. inquire ( unit = self % unit , POS = self % size_pos ) octets ( 4 ) = int ( z '00' , int8 ) octets ( 5 ) = int ( z '00' , int8 ) octets ( 6 ) = int ( z '00' , int8 ) octets ( 7 ) = int ( z '00' , int8 ) write ( self % unit , iostat = self % status ) octets ( 4 : 7 ) if ( present ( track_name )) call self % sequence_track_name ( track_name ) if ( present ( text_event )) call self % text_event ( text_event ) end subroutine !> Returns the name of the MIDI file: function get_name ( self ) class ( MIDI_file ), intent ( in ) :: self character ( len ( self % filename )) :: get_name get_name = self % filename end function !> Specifies a tempo change by writing the duration of a quarter note !> expressed in µs. It is coded on 3 bytes: from 1 µs to 256**3 µs ~ 16.7 s. !> A duration of 500000 µs = 0.5 s is equivalent to a 120 bpm tempo. !> https://en.wikipedia.org/wiki/Tempo subroutine set_tempo ( self , duration ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: duration ! 32 bits integer ( int32 ) :: d integer ( int8 ) :: octets ( 0 : 5 ) !> MIDI events must always be preceded by a \"delta time\", even if null: call self % delta_time ( 0 ) !> Metadata always begin by 0xFF. Here, these codes mean we will define !> the music tempo: octets ( 0 ) = int ( z 'FF' , int8 ) octets ( 1 ) = int ( z '51' , int8 ) octets ( 2 ) = int ( z '03' , int8 ) ! Writes the tempo value: d = checked_int32 ( duration ) octets ( 3 ) = int ( ishft ( d , - 16 ), int8 ) octets ( 4 ) = int ( ishft ( d , - 8 ), int8 ) octets ( 5 ) = int ( d , int8 ) write ( self % unit , iostat = self % status ) octets end subroutine !> The time signature includes the numerator,  the denominator, !> the number of MIDI clocks between metronome ticks, !> (there are 24 MIDI clocks per quarter note) !> and the number of 32nd notes in a quarter note. !> The number of \"MIDI clocks\" between metronome clicks. subroutine set_time_signature ( self , numerator , denominator , metronome , tsnotes ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: numerator , denominator , metronome ! 8 bits integer , optional , intent ( in ) :: tsnotes ! 8 bits integer ( int8 ) :: octets ( 0 : 6 ) ! MIDI events must always be preceded by a \"delta time\", even if null: call self % delta_time ( 0 ) ! Metadata always begin by 0xFF. Here, these bytes mean we will define ! the time signature: octets ( 0 ) = int ( z 'FF' , int8 ) octets ( 1 ) = int ( z '58' , int8 ) octets ( 2 ) = int ( z '04' , int8 ) ! The data: octets ( 3 ) = checked_int8 ( numerator ) ! That byte is the power of 2 of the denominator, for example 3 for ! a denominator whose value is 8: octets ( 4 ) = checked_int8 ( nint ( log ( real ( denominator )) / log ( 2.0 ))) octets ( 5 ) = checked_int8 ( metronome ) if ( present ( tsnotes )) then octets ( 6 ) = checked_int8 ( tsnotes ) else octets ( 6 ) = 8_int8 ! Default value end if write ( self % unit , iostat = self % status ) octets end subroutine set_time_signature !> Each channel (0..15) can use one General MIDI instrument (0..127) at !> a time. subroutine Program_Change ( self , channel , instrument ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , instrument ! 8 bits integer ( int8 ) :: octets ( 0 : 1 ) call self % delta_time ( 0 ) octets ( 0 ) = int ( z 'C0' , int8 ) + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( instrument ) write ( self % unit , iostat = self % status ) octets end subroutine !> Many MIDI parameters can be set by Control Change. See the list. subroutine Control_Change ( self , channel , type , ctl_value ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , type , ctl_value ! 8 bits integer ( int8 ) :: octets ( 0 : 2 ) call self % delta_time ( 0 ) octets ( 0 ) = int ( z 'B0' , int8 ) + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( type ) octets ( 2 ) = checked_int8 ( ctl_value ) write ( self % unit , iostat = self % status ) octets end subroutine !> Writes a Note ON event. MIDI notes are in the range 0..127 !> The attack velocity is in the range 1..127 and will set the volume. !> A Note ON event with a zero velocity is equivalent to a Note OFF. subroutine Note_ON ( self , channel , note , velocity ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note , velocity ! 8 bits integer ( int8 ) :: octets ( 0 : 2 ) octets ( 0 ) = ON + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( note ) octets ( 2 ) = checked_int8 ( velocity ) write ( self % unit , iostat = self % status ) octets end subroutine Note_ON !> Writes a Note OFF event. MIDI notes are in the range 0..127 !> The release velocity is in the range 0..127. subroutine Note_OFF ( self , channel , note , velocity ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note ! 8 bits integer , optional , intent ( in ) :: velocity ! 8 bits integer ( int8 ) :: octets ( 0 : 2 ) octets ( 0 ) = OFF + checked_int8 ( channel , upper = 15 ) octets ( 1 ) = checked_int8 ( note ) if ( present ( velocity )) then octets ( 2 ) = checked_int8 ( velocity ) else octets ( 2 ) = 64 ! Default value if no velocity captor end if write ( self % unit , iostat = self % status ) octets end subroutine Note_OFF !> Write a Note ON event, waits for its duration, and writes a Note OFF. subroutine play_note ( self , channel , note , velocity , value ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note , velocity ! 8 bits integer , intent ( in ) :: value ! 32 bits call self % delta_time ( 0 ) call self % Note_ON ( channel , note , velocity ) call self % delta_time ( checked_int32 ( value )) call self % Note_OFF ( channel , note ) end subroutine !> A track must end with 0xFF2F00. subroutine end_of_track ( self ) class ( MIDI_file ), intent ( inout ) :: self integer ( int8 ) :: octets ( 0 : 2 ) call self % delta_time ( 0 ) octets ( 0 ) = int ( z 'FF' , int8 ) octets ( 1 ) = int ( z '2F' , int8 ) octets ( 2 ) = int ( z '00' , int8 ) write ( self % unit , iostat = self % status ) octets ! Then write the size of the track at its beginning: call self % write_track_size () end subroutine !> Must be called when the track is finished. It writes its size at the !> memorized position in the track header. subroutine write_track_size ( self ) class ( MIDI_file ), intent ( inout ) :: self integer ( int8 ) :: octets ( 0 : 3 ) integer ( int32 ) :: track_size integer ( int32 ) :: pos_end_of_file ! Computes its size in bytes: inquire ( unit = self % unit , POS = pos_end_of_file ) track_size = pos_end_of_file - ( self % size_pos + 4 ) octets ( 0 ) = int ( ishft ( track_size , - 24 ), int8 ) octets ( 1 ) = int ( ishft ( track_size , - 16 ), int8 ) octets ( 2 ) = int ( ishft ( track_size , - 8 ), int8 ) octets ( 3 ) = int ( track_size , int8 ) write ( self % unit , iostat = self % status , POS = self % size_pos ) octets ! Back to the current end of the file: write ( self % unit , iostat = self % status , POS = pos_end_of_file ) end subroutine !> This subroutine is used my many events. !> The text must be coded in ASCII (7 bits). subroutine write_string ( self , event , text ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: event ! 8 bits character ( len =* ), intent ( in ) :: text integer ( int8 ) :: octets ( 0 : 1 ) integer :: i call self % delta_time ( 0 ) octets ( 0 ) = int ( z 'FF' , int8 ) octets ( 1 ) = checked_int8 ( event ) write ( self % unit , iostat = self % status ) octets call self % write_variable_length_quantity ( len ( text )) do i = 1 , len ( text ) ! We suppose the system is using ASCII: write ( self % unit , iostat = self % status ) iachar ( text ( i : i ), int8 ) end do end subroutine !> Text event: FF 01 len text subroutine text_event ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 1 , text = text ) end subroutine !> Copyright Notice event: FF 02 len text subroutine copyright_notice ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 2 , text = text ) end subroutine !> Sequence or Track Name event: FF 03 len text subroutine sequence_track_name ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 3 , text = text ) end subroutine !> Instrument Name event: FF 04 len text subroutine instrument_name ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 4 , text = text ) end subroutine !> Lyric event: FF 05 len text subroutine lyric ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 5 , text = text ) end subroutine !> Marker event: FF 06 len text subroutine marker ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 6 , text = text ) end subroutine !> Cue Point event: FF 07 len text subroutine cue_point ( self , text ) class ( MIDI_file ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: text call self % write_string ( event = 7 , text = text ) end subroutine !> Writes a chord, waits for its duration, and writes the OFF events subroutine play_chord ( self , channel , note , chord , velocity , value ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note ! 8 bits integer , dimension (:), intent ( in ) :: chord integer , intent ( in ) :: velocity ! 8 bits integer , intent ( in ) :: value ! 32 bits integer :: i do i = 1 , size ( chord ) call self % delta_time ( 0 ) call self % Note_ON ( channel , note + chord ( i ), velocity ) end do call self % delta_time ( checked_int32 ( value )) do i = 1 , size ( chord ) call self % Note_OFF ( channel , note + chord ( i )) if ( i < size ( chord )) call self % delta_time ( 0 ) end do end subroutine !> Writes a broken chord using an array containing the intervals !> (see the music_common module). !> For the moment, each note has the same duration. !> https://en.wikipedia.org/wiki/Arpeggio subroutine play_broken_chord ( self , channel , note , chord , velocity , value ) class ( MIDI_file ), intent ( inout ) :: self integer , intent ( in ) :: channel , note ! 8 bits integer , dimension (:), intent ( in ) :: chord integer , intent ( in ) :: velocity ! 8 bits integer , intent ( in ) :: value ! 32 bits integer ( int32 ) :: dnote , residual integer :: i dnote = nint ( real ( checked_int32 ( value )) / size ( chord )) ! The MIDI duration being an integer, the last note of the chord may ! have a slightly different duration to keep the total duration exact: residual = checked_int32 ( value ) - dnote * ( size ( chord ) - 1 ) call self % delta_time ( 0 ) do i = 1 , size ( chord ) call self % Note_ON ( channel , note + chord ( i ), velocity ) if ( i < size ( chord )) then call self % delta_time ( dnote ) else call self % delta_time ( residual ) end if end do do i = 1 , size ( chord ) call self % Note_OFF ( channel , note + chord ( i )) ! The delta time must always be placed before a note: if ( i < size ( chord )) call self % delta_time ( 0 ) end do end subroutine play_broken_chord end module MIDI_file_class","tags":"","loc":"sourcefile/midi_file_class.f90.html"},{"title":"circle_of_fifths.f90 – ForMIDI","text":"This file depends on sourcefile~~circle_of_fifths.f90~~EfferentGraph sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~circle_of_fifths.f90->sourcefile~gm_instruments.f90 sourcefile~midi_control_changes.f90 MIDI_control_changes.f90 sourcefile~circle_of_fifths.f90->sourcefile~midi_control_changes.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~circle_of_fifths.f90->sourcefile~midi_file_class.f90 sourcefile~music.f90 music.f90 sourcefile~circle_of_fifths.f90->sourcefile~music.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music and exploring !          algorithmic music ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-22 !-------------------------------------- !> A random walk on the circle of fifths !-------------------------------------- program circle_of_fifths use , intrinsic :: iso_fortran_env , only : dp => real64 use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi integer :: channel , instrument , velocity , note character ( 3 ) :: name logical :: major integer , parameter :: length = 200 integer :: i real ( dp ) :: p ! Create a file with 2 tracks (including the metadata track): ! The first track is always a metadata track. We define the ! tempo: a quarter note will last 500000 µs = 0.5 s => tempo = 120 bpm call midi % new ( \"circle_of_fifths.mid\" , format = 1 , tracks = 2 , divisions = quarter_note , tempo = 500000 ) ! (1) The single music track: call midi % track_header () ! Sounds also good with instruments String_Ensemble_2 and Pad_8_sweep: instrument = Choir_Aahs ! We will use altenatively MIDI channels 0 and 1 to avoid cutting ! the tail of each chord: call midi % Program_Change ( channel = 0 , instrument = instrument ) call midi % Program_Change ( channel = 1 , instrument = instrument ) ! Heavy (127) reverb effect: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 127 ) ! Reverb call midi % Control_Change ( channel = 1 , type = Effects_1_Depth , ctl_value = 127 ) ! Reverb ! We start with C Major (note at the top of the Major circle): note = 1 major = . true . name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( note )) // \"4\" call midi % play_chord ( channel = 0 , note = MIDI_Note ( name ), chord = MAJOR_CHORD , velocity = f_level + 10 , value = whole_note ) ! A random walk with three events: we can go one note clockwise, ! one note counterclockwise or switch Major<->minor. do i = 1 , length ! A random number 0 <= p < 3 call random_number ( p ) p = 3 * p ! The three possible events: if ( p >= 2.0_dp ) then note = note + 1 if ( note > 12 ) note = 1 else if ( p >= 1.0_dp ) then note = note - 1 if ( note < 1 ) note = 12 else major = . not . major end if ! Alternate between channels 0 and 1: channel = mod ( i , 2 ) ! The volume will evolve, to obtain some dynamics: velocity = f_level + 10 + int ( 20 * sin ( real ( i ))) ! Write a major or minor chord on the track: if ( major ) then name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( note )) // \"4\" call midi % play_chord ( channel , MIDI_Note ( name ), MAJOR_CHORD , velocity , whole_note ) else name = trim ( CIRCLE_OF_FIFTHS_MINOR ( note )) // \"4\" call midi % play_chord ( channel , MIDI_Note ( name ), MINOR_CHORD , velocity , whole_note ) end if end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program circle_of_fifths","tags":"","loc":"sourcefile/circle_of_fifths.f90.html"},{"title":"MIDI_control_changes.f90 – ForMIDI","text":"Files dependent on this one sourcefile~~midi_control_changes.f90~~AfferentGraph sourcefile~midi_control_changes.f90 MIDI_control_changes.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~midi_control_changes.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~midi_control_changes.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~midi_control_changes.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~midi_control_changes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-14 !> MIDI 1.0 Control Change Messages and Registered Parameter Numbers (RPNs) module MIDI_control_changes implicit none public integer , parameter :: Bank_Select = 0 integer , parameter :: Modulation_Wheel_or_Lever = 1 integer , parameter :: Breath_Controller = 2 ! Undefined = 3 integer , parameter :: Foot_Controller = 4 integer , parameter :: Portamento_Time = 5 integer , parameter :: Data_Entry_MSB = 6 integer , parameter :: Channel_Volume = 7 ! (formerly_Main_Volume) integer , parameter :: Balance = 8 ! Undefined = 9 integer , parameter :: Pan = 10 integer , parameter :: Expression_Controller = 11 integer , parameter :: Effect_Control_1 = 12 integer , parameter :: Effect_Control_2 = 13 ! Undefined 14-15 integer , parameter :: General_Purpose_Controller_1 = 16 integer , parameter :: General_Purpose_Controller_2 = 17 integer , parameter :: General_Purpose_Controller_3 = 18 integer , parameter :: General_Purpose_Controller_4 = 19 ! Undefined 20-31 integer , parameter :: Bank_Select_LSB = 32 integer , parameter :: Modulation_Wheel_or_Lever_LSB = 33 integer , parameter :: Breath_Controller_LSB = 34 ! Undefined = 35 integer , parameter :: Foot_Controller_LSB = 36 integer , parameter :: Portamento_Time_LSB = 37 integer , parameter :: Data_Entry_MSB_LSB = 38 integer , parameter :: Channel_Volume_LSB = 39 ! (formerly_Main_Volume) integer , parameter :: Balance_LSB = 40 ! Undefined = 41 integer , parameter :: Pan_LSB = 42 integer , parameter :: Expression_Controller_LSB = 43 integer , parameter :: Effect_Control_1_LSB = 44 integer , parameter :: Effect_Control_2_LSB = 45 ! Undefined 46-47 integer , parameter :: General_Purpose_Controller_1_LSB = 48 integer , parameter :: General_Purpose_Controller_2_LSB = 49 integer , parameter :: General_Purpose_Controller_3_LSB = 50 integer , parameter :: General_Purpose_Controller_4_LSB = 51 ! Undefined 52-63 integer , parameter :: Damper_Pedal_on_off = 64 ! (Sustain) integer , parameter :: Portamento_On_Off = 65 integer , parameter :: Sostenuto_On_Off = 66 integer , parameter :: Soft_Pedal_On_Off = 67 integer , parameter :: Legato_Footswitch = 68 integer , parameter :: Hold_2 = 69 integer , parameter :: Sound_Controller_1 = 70 ! (default: Sound_Variation) integer , parameter :: Sound_Controller_2 = 71 ! (default: Timbre_Harmonic_Intens.) integer , parameter :: Sound_Controller_3 = 72 ! (default: Release_Time) integer , parameter :: Sound_Controller_4 = 73 ! (default: Attack_Time) integer , parameter :: Sound_Controller_5 = 74 ! (default: Brightness) integer , parameter :: Sound_Controller_6 = 75 ! (default: Decay_Time - see_MMA_RP-021) integer , parameter :: Sound_Controller_7 = 76 ! (default: Vibrato_Rate - see_MMA_RP-021) integer , parameter :: Sound_Controller_8 = 77 ! (default: Vibrato_Depth - see_MMA_RP-021) integer , parameter :: Sound_Controller_9 = 78 ! (default: Vibrato_Delay - see_MMA_RP-021) integer , parameter :: Sound_Controller_10 = 79 ! (default_undefined - see_MMA_RP-021) integer , parameter :: General_Purpose_Controller_5 = 80 integer , parameter :: General_Purpose_Controller_6 = 81 integer , parameter :: General_Purpose_Controller_7 = 82 integer , parameter :: General_Purpose_Controller_8 = 83 integer , parameter :: Portamento_Control = 84 ! Undefined_85-87 integer , parameter :: High_Resolution_Velocity_Prefix = 88 ! Undefined_89-90 integer , parameter :: Effects_1_Depth = 91 ! (default: Reverb_Send_Level - see_MMA_RP-023, ! formerly_External_Effects_Depth) integer , parameter :: Effects_2_Depth = 92 ! (formerly_Tremolo_Depth) integer , parameter :: Effects_3_Depth = 93 ! (default: Chorus_Send_Level - see_MMA_RP-023)  (formerly_Chorus_Depth) integer , parameter :: Effects_4_Depth = 94 ! (formerly_Celeste [Detune] Depth) integer , parameter :: Effects_5_Depth = 95 ! (formerly_Phaser_Depth) integer , parameter :: Data_Increment = 96 ! (Data_Entry +1) (see_MMA_RP-018) integer , parameter :: Data_Decrement = 97 ! (Data_Entry -1) (see_MMA_RP-018) integer , parameter :: Non_Registered_Parameter_Number_LSB = 98 ! (NRPN) - LSB integer , parameter :: Non_Registered_Parameter_Number_MSB = 99 ! (NRPN) - MSB integer , parameter :: Registered_Parameter_Number_LSB = 100 ! (RPN) - LSB* integer , parameter :: Registered_Parameter_Number_MSB = 101 ! (RPN) - MSB* ! Undefined_102-119 integer , parameter :: All_Sound_Off = 120 ! [Channel_Mode_Message] integer , parameter :: Reset_All_Controllers = 121 ! [Channel_Mode_Message] (See_MMA_RP-015) integer , parameter :: Local_Control_On_Off = 122 ! [Channel_Mode_Message] integer , parameter :: All_Notes_Off = 123 ! [Channel_Mode_Message] integer , parameter :: Omni_Mode_Off = 124 ! (+ all_notes_off) [Channel_Mode_Message] integer , parameter :: Omni_Mode_On = 125 ! (+ all_notes_off) [Channel_Mode_Message] integer , parameter :: Mono_Mode_On = 126 ! (+ poly_off, + all_notes_off) [Channel_Mode_Message] integer , parameter :: Poly_Mode_On = 127 ! (+ mono_off, +all_notes_off) [Channel_Mode_Message] end module MIDI_control_changes","tags":"","loc":"sourcefile/midi_control_changes.f90.html"},{"title":"third_kind.f90 – ForMIDI","text":"This file depends on sourcefile~~third_kind.f90~~EfferentGraph sourcefile~third_kind.f90 third_kind.f90 sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~third_kind.f90->sourcefile~gm_instruments.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~third_kind.f90->sourcefile~midi_file_class.f90 sourcefile~music.f90 music.f90 sourcefile~third_kind.f90->sourcefile~music.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music and exploring !          algorithmic music ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-22 !> This is your starting point in the ForMIDI world. !> Close Encounters of the Third Kind: https://www.youtube.com/watch?v=S4PYI6TzqYk program third_kind ! The main class you need to create music: use MIDI_file_class ! The function MIDI_Note() returns the MIDI number of a note from 12 (C0) ! to 127 (G9). The A4 (440 Hz tuning standard) is the note 69. use music ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi !> You will generally use the format SMF 1 which allows several tracks !> to be played together. !> We will use only one musical track but we need 2 tracks, as there is !> always a metadata track automatically created by the new() method. !> Divisions is the number of ticks (\"metrical timing\" MIDI scheme) in !> a quarter note, and can be considered as the time resolution of your file. ! We define the tempo: a quarter note will last 500000 µs = 0.5 s => tempo=120 bpm call midi % new ( \"third_kind.mid\" , format = 1 , tracks = 2 , divisions = quarter_note , tempo = 500000 , & & text_event = \"This file was created with the ForMIDI Fortran project\" ) ! (1) The single musical track: call midi % track_header () ! Choosing the instrument (in the 0..127 range): call midi % Program_Change ( channel = 0 , instrument = Pad_6_metallic ) ! Playing a sequence of five notes on MIDI channel 0: call midi % play_note ( channel = 0 , note = MIDI_Note ( \"G4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"A4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"F4\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"F3\" ), velocity = mf_level , value = quarter_note ) call midi % play_note ( channel = 0 , note = MIDI_Note ( \"C4\" ), velocity = mf_level , value = half_note ) !> The MIDI velocity is the speed at which you type on the keyboard and !> can be considered equivalent to the volume. As many MIDI values, it is !> defined in the 0..127 range. !> There are 16 channels (0..15). !> The value (duration) of a note is expressed in MIDI ticks. call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program third_kind","tags":"","loc":"sourcefile/third_kind.f90.html"},{"title":"GM_instruments.f90 – ForMIDI","text":"Files dependent on this one sourcefile~~gm_instruments.f90~~AfferentGraph sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~gm_instruments.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~gm_instruments.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~gm_instruments.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~gm_instruments.f90 sourcefile~third_kind.f90 third_kind.f90 sourcefile~third_kind.f90->sourcefile~gm_instruments.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-14 !--------------------------------------------------------------------------- !> Contains the list of General MIDI 128 instruments and 47 percussions !--------------------------------------------------------------------------- module GM_instruments implicit none public !----------------------------------- !> GM instruments, grouped by family: !----------------------------------- ! Piano integer , parameter :: Acoustic_Grand_Piano = 0 integer , parameter :: Bright_Acoustic_Piano = 1 integer , parameter :: Electric_Grand_Piano = 2 integer , parameter :: Honky_tonk_Piano = 3 integer , parameter :: Electric_Piano_1 = 4 integer , parameter :: Electric_Piano_2 = 5 integer , parameter :: Harpsichord = 6 integer , parameter :: Clavi = 7 ! Chromatic Percussion integer , parameter :: Celesta = 8 integer , parameter :: Glockenspiel = 9 integer , parameter :: Music_Box = 10 integer , parameter :: Vibraphone = 11 integer , parameter :: Marimba = 12 integer , parameter :: Xylophone = 13 integer , parameter :: Tubular_Bells = 14 integer , parameter :: Dulcimer = 15 ! Organ integer , parameter :: Drawbar_Organ = 16 integer , parameter :: Percussive_Organ = 17 integer , parameter :: Rock_Organ = 18 integer , parameter :: Church_Organ = 19 integer , parameter :: Reed_Organ = 20 integer , parameter :: Accordion = 21 integer , parameter :: Harmonica = 22 integer , parameter :: Tango_Accordion = 23 ! Guitar integer , parameter :: Acoustic_Guitar_nylon = 24 integer , parameter :: Acoustic_Guitar_steel = 25 integer , parameter :: Electric_Guitar_jazz = 26 integer , parameter :: Electric_Guitar_clean = 27 integer , parameter :: Electric_Guitar_muted = 28 integer , parameter :: Overdriven_Guitar = 29 integer , parameter :: Distortion_Guitar = 30 integer , parameter :: Guitar_harmonics = 31 ! Bass integer , parameter :: Acoustic_Bass = 32 integer , parameter :: Electric_Bass_finger = 33 integer , parameter :: Electric_Bass_pick = 34 integer , parameter :: Fretless_Bass = 35 integer , parameter :: Slap_Bass_1 = 36 integer , parameter :: Slap_Bass_2 = 37 integer , parameter :: Synth_Bass_1 = 38 integer , parameter :: Synth_Bass_2 = 39 ! Strings integer , parameter :: Violin = 40 integer , parameter :: Viola = 41 integer , parameter :: Cello = 42 integer , parameter :: Contrabass = 43 integer , parameter :: Tremolo_Strings = 44 integer , parameter :: Pizzicato_Strings = 45 integer , parameter :: Orchestral_Harp = 46 integer , parameter :: Timpani = 47 ! Ensemble integer , parameter :: String_Ensemble_1 = 48 integer , parameter :: String_Ensemble_2 = 49 integer , parameter :: SynthStrings_1 = 50 integer , parameter :: SynthStrings_2 = 51 integer , parameter :: Choir_Aahs = 52 integer , parameter :: Voice_Oohs = 53 integer , parameter :: Synth_Voice = 54 integer , parameter :: Orchestra_Hit = 55 ! Brass integer , parameter :: Trumpet = 56 integer , parameter :: Trombone = 57 integer , parameter :: Tuba = 58 integer , parameter :: Muted_Trumpet = 59 integer , parameter :: French_Horn = 60 integer , parameter :: Brass_Section = 61 integer , parameter :: SynthBrass_1 = 62 integer , parameter :: SynthBrass_2 = 63 ! Reed integer , parameter :: Soprano_Sax = 64 integer , parameter :: Alto_Sax = 65 integer , parameter :: Tenor_Sax = 66 integer , parameter :: Baritone_Sax = 67 integer , parameter :: Oboe = 68 integer , parameter :: English_Horn = 69 integer , parameter :: Bassoon = 70 integer , parameter :: Clarinet = 71 ! Pipe integer , parameter :: Piccolo = 72 integer , parameter :: Flute = 73 integer , parameter :: Recorder = 74 integer , parameter :: Pan_Flute = 75 integer , parameter :: Blown_Bottle = 76 integer , parameter :: Shakuhachi = 77 integer , parameter :: Whistle = 78 integer , parameter :: Ocarina = 79 ! Synth Lead integer , parameter :: Lead_1_square = 80 integer , parameter :: Lead_2_sawtooth = 81 integer , parameter :: Lead_3_calliope = 82 integer , parameter :: Lead_4_chiff = 83 integer , parameter :: Lead_5_charang = 84 integer , parameter :: Lead_6_voice = 85 integer , parameter :: Lead_7_fifths = 86 integer , parameter :: Lead_8_bass_lead = 87 ! Synth Pad integer , parameter :: Pad_1_new_age = 88 integer , parameter :: Pad_2_warm = 89 integer , parameter :: Pad_3_polysynth = 90 integer , parameter :: Pad_4_choir = 91 integer , parameter :: Pad_5_bowed = 92 integer , parameter :: Pad_6_metallic = 93 integer , parameter :: Pad_7_halo = 94 integer , parameter :: Pad_8_sweep = 95 ! Synth Effects integer , parameter :: FX_1_rain = 96 integer , parameter :: FX_2_soundtrack = 97 integer , parameter :: FX_3_crystal = 98 integer , parameter :: FX_4_atmosphere = 99 integer , parameter :: FX_5_brightness = 100 integer , parameter :: FX_6_goblins = 101 integer , parameter :: FX_7_echoes = 102 integer , parameter :: FX_8_sci_fi = 103 ! Ethnic integer , parameter :: Sitar = 104 integer , parameter :: Banjo = 105 integer , parameter :: Shamisen = 106 integer , parameter :: Koto = 107 integer , parameter :: Kalimba = 108 integer , parameter :: Bag_pipe = 109 integer , parameter :: Fiddle = 110 integer , parameter :: Shanai = 111 ! Percussive integer , parameter :: Tinkle_Bell = 112 integer , parameter :: Agogo = 113 integer , parameter :: Steel_Drums = 114 integer , parameter :: Woodblock = 115 integer , parameter :: Taiko_Drum = 116 integer , parameter :: Melodic_Tom = 117 integer , parameter :: Synth_Drum = 118 integer , parameter :: Reverse_Cymbal = 119 ! Sound Effects integer , parameter :: Guitar_Fret_Noise = 120 integer , parameter :: Breath_Noise = 121 integer , parameter :: Seashore = 122 integer , parameter :: Bird_Tweet = 123 integer , parameter :: Telephone_Ring = 124 integer , parameter :: Helicopter = 125 integer , parameter :: Applause = 126 integer , parameter :: Gunshot = 127 !> Percussive instruments (channel 9). This  list is required by the GM standard, !> but more may be available: integer , parameter :: Acoustic_Bass_Drum = 35 integer , parameter :: Bass_Drum_1 = 36 integer , parameter :: Side_Stick = 37 integer , parameter :: Acoustic_Snare = 38 integer , parameter :: Hand_Clap = 39 integer , parameter :: Electric_Snare = 40 integer , parameter :: Low_Floor_Tom = 41 integer , parameter :: Closed_Hi_Hat = 42 integer , parameter :: High_Floor_Tom = 43 integer , parameter :: Pedal_Hi_Hat = 44 integer , parameter :: Low_Tom = 45 integer , parameter :: Open_Hi_Hat = 46 integer , parameter :: Low_Mid_Tom = 47 integer , parameter :: Hi_Mid_Tom = 48 integer , parameter :: Crash_Cymbal_1 = 49 integer , parameter :: High_Tom = 50 integer , parameter :: Ride_Cymbal_1 = 51 integer , parameter :: Chinese_Cymbal = 52 integer , parameter :: Ride_Bell = 53 integer , parameter :: Tambourine = 54 integer , parameter :: Splash_Cymbal = 55 integer , parameter :: Cowbell = 56 integer , parameter :: Crash_Cymbal_2 = 57 integer , parameter :: Vibraslap = 58 integer , parameter :: Ride_Cymbal_2 = 59 integer , parameter :: Hi_Bongo = 60 integer , parameter :: Low_Bongo = 61 integer , parameter :: Mute_Hi_Conga = 62 integer , parameter :: Open_Hi_Conga = 63 integer , parameter :: Low_Conga = 64 integer , parameter :: High_Timbale = 65 integer , parameter :: Low_Timbale = 66 integer , parameter :: High_Agogo = 67 integer , parameter :: Low_Agogo = 68 integer , parameter :: Cabasa = 69 integer , parameter :: Maracas = 70 integer , parameter :: Short_Whistle = 71 integer , parameter :: Long_Whistle = 72 integer , parameter :: Short_Guiro = 73 integer , parameter :: Long_Guiro = 74 integer , parameter :: Claves = 75 integer , parameter :: Hi_Wood_Block = 76 integer , parameter :: Low_Wood_Block = 77 integer , parameter :: Mute_Cuica = 78 integer , parameter :: Open_Cuica = 79 integer , parameter :: Mute_Triangle = 80 integer , parameter :: Open_Triangle = 81 end module GM_instruments","tags":"","loc":"sourcefile/gm_instruments.f90.html"},{"title":"canon.f90 – ForMIDI","text":"This file depends on sourcefile~~canon.f90~~EfferentGraph sourcefile~canon.f90 canon.f90 sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~canon.f90->sourcefile~gm_instruments.f90 sourcefile~midi_control_changes.f90 MIDI_control_changes.f90 sourcefile~canon.f90->sourcefile~midi_control_changes.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~canon.f90->sourcefile~midi_file_class.f90 sourcefile~music.f90 music.f90 sourcefile~canon.f90->sourcefile~music.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music and exploring !          algorithmic music ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-22 !> An example based on the first measures of Pachelbel's Canon !> https://en.wikipedia.org/wiki/Pachelbel%27s_Canon program canon use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi ! Notes of the bass and theme: character ( 3 ), parameter :: bass ( 1 : 8 ) = [ \"D3 \" , \"A2 \" , \"B2 \" , \"F#2\" , \"G2 \" , & & \"D2 \" , \"G2 \" , \"A2 \" ] character ( 3 ), parameter :: theme ( 1 : 16 ) = [ \"F#5\" , \"E5 \" , \"D5 \" , \"C#5\" , & & \"B4 \" , \"A4 \" , \"B4 \" , \"C#5\" , & & \"D5 \" , \"C#5\" , \"B4 \" , \"A4 \" , & & \"G4 \" , \"F#4\" , \"G4 \" , \"E4 \" ] ! List of General MIDI instruments to use sequentially: integer , parameter :: instrument ( 1 : 17 ) = [ 40 , 41 , 42 , 44 , 45 , 48 ,& & 49 , 51 , 52 , 89 , 90 , 91 , 92 , 94 , 95 , 99 , 100 ] ! Pan value for each track: integer , parameter :: panning ( 2 : 5 ) = [ 54 , 34 , 74 , 94 ] integer :: track character ( 13 ) :: track_name integer :: i , j ! Create a file with 5 tracks (including the metadata track): ! A quarter note will last 1000000 µs = 1 s => tempo = 60 bpm call midi % new ( \"canon.mid\" , format = 1 , tracks = 5 , divisions = quarter_note , tempo = 1000000 , copyright = \"Public domain\" ) ! (1) A first music track: ground bass call midi % track_header ( track_name = \"ground bass\" ) call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Reverb ! Instrument on channel 0: call midi % Program_Change ( channel = 0 , instrument = String_Ensemble_1 ) ! Panning: call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = panning ( 2 )) do j = 1 , 30 do i = 1 , 8 call midi % play_note ( channel = 0 , note = MIDI_Note ( bass ( i )), velocity = mf_level , value = quarter_note ) end do end do call midi % end_of_track () ! Three other music tracks: a three voices canon with various instruments do track = 3 , 5 write ( track_name , '(\"Canon voice \",I0)' ) track - 2 call midi % track_header ( track_name ) ! Reverb and pan: call midi % Control_Change ( channel = track , type = Effects_1_Depth , ctl_value = 64 ) call midi % Control_Change ( channel = track , type = Pan , ctl_value = panning ( track )) ! A pause to shift the start of each voice of the canon: call midi % play_note ( channel = track , note = 0 , velocity = 0 , value = 8 * quarter_note * ( track - 2 )) do j = 1 , 15 ! Let's change regularly the instruments to add some variations: call midi % Program_Change ( channel = track , instrument = instrument (( track - 3 ) + j )) ! Let's play the theme: do i = 1 , 16 call midi % play_note ( channel = track , note = MIDI_Note ( theme ( i )), velocity = mf_level , value = quarter_note ) end do end do call midi % end_of_track () end do call midi % close () print * , \"You can now play the file \" , midi % get_name () end program canon","tags":"","loc":"sourcefile/canon.f90.html"},{"title":"blues.f90 – ForMIDI","text":"This file depends on sourcefile~~blues.f90~~EfferentGraph sourcefile~blues.f90 blues.f90 sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~blues.f90->sourcefile~gm_instruments.f90 sourcefile~midi_control_changes.f90 MIDI_control_changes.f90 sourcefile~blues.f90->sourcefile~midi_control_changes.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~blues.f90->sourcefile~midi_file_class.f90 sourcefile~music.f90 music.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music and exploring !          algorithmic music ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-22 !> A stochastic blues program blues use , intrinsic :: iso_fortran_env , only : dp => real64 use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Modulation_Wheel_or_Lever , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi real ( dp ) :: p , delta integer :: i , j , jmax integer , parameter :: nb_notes = 6 integer , parameter :: length = 200 integer :: b_scale ( 0 : 127 ) ! Blues scale integer :: octave , note , value logical :: again ! The tonic is the C note: integer :: tonic tonic = MIDI_Note ( \"C1\" ) ! Create a file with 3 tracks (including the metadata track): ! A quarter note will last 1000000 µs = 1 s => tempo = 60 bpm call midi % new ( \"blues.mid\" , format = 1 , tracks = 3 , divisions = quarter_note , tempo = 1000000 ) ! (1) A first music track with guitar: call midi % track_header () ! Reverb: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Modulation: call midi % Control_Change ( channel = 0 , type = Modulation_Wheel_or_Lever , ctl_value = 40 ) ! Panning, slightly on the left (center is 64): call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = 44 ) ! Instrument: call midi % Program_Change ( channel = 0 , instrument = Distortion_Guitar ) ! A blues scale C, Eb, F, Gb, G, Bb, repeated at each octave. ! The MIDI note 0 is a C-1, but can not be heard (f=8.18 Hz). ! https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale ! We copy the blues scale at the beginning of the array: do j = 0 , 5 b_scale ( j ) = MIDI_Note ( trim ( HEXATONIC_BLUES_SCALE ( j + 1 )) // \"0\" ) - 12 end do ! And we copy it as many times as possible: jmax = nb_notes - 1 octave = 1 again = . true . do do j = 0 , nb_notes - 1 if ( b_scale ( j ) + octave * 12 <= 127 ) then jmax = octave * nb_notes + j b_scale ( jmax ) = b_scale ( j ) + octave * 12 else again = . false . end if end do octave = octave + 1 if (. not . again ) exit end do ! Let's make a random walk on that scale: value = quarter_note note = tonic do i = 1 , length call midi % play_chord ( channel = 0 , note = b_scale ( note ), chord = POWER_CHORD , velocity = p_level - 2 , value = value ) ! Random walk: call random_number ( p ) ! We need a kind of restoring force to avoid going too far: delta = (( b_scale ( note ) - b_scale ( tonic )) / 1 2.0_dp ) * 0.45_dp if ( p >= 0.55_dp + delta ) then if ( note < jmax ) note = note + 1 else if ( p >= 0.1_dp ) then if ( note > 0 ) note = note - 1 end if ! Duration: call random_number ( p ) if ( p >= 0.75_dp ) then value = quarter_note else value = sixteenth_note end if end do call midi % end_of_track () ! (2) Drums track (channel 9 by default): call midi % track_header () ! Reverb: call midi % Control_Change ( channel = drums , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the right (center is 64): call midi % Control_Change ( channel = drums , type = Pan , ctl_value = 84 ) do i = 1 , length * 2 call midi % delta_time ( 0 ) ! On the drum channel, each note corresponds to a percussion: call midi % Note_ON ( channel = drums , note = Closed_Hi_Hat , velocity = 80 ) ! We use modulo to create a rhythm: if ( mod ( i , 6 ) == 4 ) then call midi % delta_time ( 0 ) call midi % Note_ON ( channel = drums , note = Acoustic_Snare , velocity = 92 ) else if (( mod ( i , 6 ) == 1 ) . or . ( mod ( i , 12 ) == 6 )) then call midi % delta_time ( 0 ) call midi % Note_ON ( channel = drums , note = Acoustic_Bass_Drum , velocity = 127 ) end if call midi % delta_time ( quarter_note / 3 ) call midi % Note_OFF ( channel = drums , note = Closed_Hi_Hat , velocity = 64 ) if ( mod ( i , 6 ) == 4 ) then call midi % delta_time ( 0 ) call midi % Note_OFF ( channel = drums , note = Acoustic_Snare , velocity = 92 ) else if (( mod ( i , 6 ) == 1 ) . or . ( mod ( i , 12 ) == 6 )) then call midi % delta_time ( 0 ) call midi % Note_OFF ( channel = drums , note = Acoustic_Bass_Drum , velocity = 127 ) end if end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () end program blues","tags":"","loc":"sourcefile/blues.f90.html"},{"title":"utilities.f90 – ForMIDI","text":"Files dependent on this one sourcefile~~utilities.f90~~AfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music.f90 music.f90 sourcefile~music.f90->sourcefile~utilities.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~midi_file_class.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~canon.f90 canon.f90 sourcefile~canon.f90->sourcefile~midi_file_class.f90 sourcefile~canon.f90->sourcefile~music.f90 sourcefile~circle_of_fifths.f90 circle_of_fifths.f90 sourcefile~circle_of_fifths.f90->sourcefile~midi_file_class.f90 sourcefile~circle_of_fifths.f90->sourcefile~music.f90 sourcefile~la_folia.f90 la_folia.f90 sourcefile~la_folia.f90->sourcefile~midi_file_class.f90 sourcefile~la_folia.f90->sourcefile~music.f90 sourcefile~third_kind.f90 third_kind.f90 sourcefile~third_kind.f90->sourcefile~midi_file_class.f90 sourcefile~third_kind.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-14 !> Functions to check the bounds of int8, int16, int32 values. module utilities use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , error_unit implicit none public :: checked_int8 , checked_int16 , checked_int32 contains !> Receives a default kind integer, checks its MIDI bounds (15 or 127), !> fixes it if needed, and returns an int8: function checked_int8 ( i , upper ) result ( i8 ) integer , intent ( in ) :: i integer , optional , intent ( in ) :: upper !  The upper limit integer :: u integer ( int8 ) :: i8 if ( present ( upper )) then u = upper else u = 127 end if if (( i < 0 ). or .( i > u )) then if ( i < 0 ) i8 = 0_int8 if ( i > u ) i8 = int ( u , kind = int8 ) write ( error_unit , '(\"WARNING: int8 out of range [0 ; \", I0, \"] => corrected to \", I0)' ) u , i8 else i8 = int ( i , kind = int8 ) end if end function !> Receives a default kind integer, checks its bounds (Fortran signed int), !> fixes it if needed, and returns an int16: function checked_int16 ( i ) result ( i16 ) integer , intent ( in ) :: i integer ( int16 ) :: i16 if (( i < 0 ). or .( i > 32767 )) then if ( i < 0 ) i16 = 0_int16 if ( i > 32767 ) i16 = 32767_int16 write ( error_unit , * ) \"WARNING: int16 out of range [0 ; 32767] => corrected to \" , i16 else i16 = int ( i , kind = int16 ) end if end function !> Receives a default kind integer, checks its bounds (Fortran signed int), !> fixes it if needed, and returns an int32. function checked_int32 ( i ) result ( i32 ) integer , intent ( in ) :: i integer ( int32 ) :: i32 if (( i < 0 ). or .( i > 2147483647 )) then if ( i < 0 ) i32 = 0_int32 if ( i > 2147483647 ) i32 = 2147483647_int32 write ( error_unit , * ) \"WARNING: int32 out of range [0 ; 2147483647] => corrected to \" , i32 else i32 = int ( i , kind = int32 ) end if end function end module utilities","tags":"","loc":"sourcefile/utilities.f90.html"},{"title":"la_folia.f90 – ForMIDI","text":"This file depends on sourcefile~~la_folia.f90~~EfferentGraph sourcefile~la_folia.f90 la_folia.f90 sourcefile~gm_instruments.f90 GM_instruments.f90 sourcefile~la_folia.f90->sourcefile~gm_instruments.f90 sourcefile~midi_control_changes.f90 MIDI_control_changes.f90 sourcefile~la_folia.f90->sourcefile~midi_control_changes.f90 sourcefile~midi_file_class.f90 MIDI_file_class.f90 sourcefile~la_folia.f90->sourcefile~midi_file_class.f90 sourcefile~music.f90 music.f90 sourcefile~la_folia.f90->sourcefile~music.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~midi_file_class.f90->sourcefile~utilities.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music and exploring !          algorithmic music ! License GPL-3.0-or-later ! Vincent Magnin, 2024-06-05 ! Last modifications: 2024-06-23 !> An example on the classical Portuguese/Spanish theme of La Folia !> https://en.wikipedia.org/wiki/Folia program la_folia use MIDI_file_class use music use MIDI_control_changes , only : Effects_1_Depth , Pan ! Contains the list of General MIDI 128 instruments and 47 percussions: use GM_instruments implicit none type ( MIDI_file ) :: midi integer :: n , d character ( 3 ) :: note , chord_type , note_value integer , dimension ( 3 ) :: arpeggio1 , arpeggio2 ! Chords of the Folia theme in D minor. ! This is a first attempt to encode a chord into a string with its fundamental, ! its type (M, m, 7th...) and its value (w, q, h, etc.). ! That system may evolve in the future. ! https://en.wikipedia.org/wiki/Note_value character ( 7 ), parameter :: chords ( 1 : 17 ) = [ \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" , \"C3 M h.\" , & & \"F3 M h.\" , \"C3 M h.\" , \"D3 m h.\" , \"A2 7 h.\" , & & \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" , \"C3 M h.\" , & & \"F3 M h.\" , \"C3 M h.\" , \"D3 m h.\" , \"A2 7 h.\" , \"D3 m h.\" ] integer :: i , j ! Create a file with 3 tracks (including the metadata track): ! A quarter note will last 600000 µs = 0.6 s => tempo = 100 bpm ! The time signature is 3/4 (this argument is optional with 4/4 for default value). call midi % new ( \"la_folia.mid\" , format = 1 , tracks = 3 , divisions = quarter_note , tempo = 600000 , & & time_signature = [ 3 , 4 ], copyright = \"Public domain\" ) ! (1) A track with chords played by strings on MIDI channel 0 call midi % track_header ( track_name = \"chords\" ) ! Reverb: call midi % Control_Change ( channel = 0 , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the left (center is 64): call midi % Control_Change ( channel = 0 , type = Pan , ctl_value = 44 ) ! Choosing the instrument: call midi % Program_Change ( channel = 0 , instrument = String_Ensemble_1 ) ! We repeat the theme three times identically: do j = 1 , 3 do i = 1 , 17 call analyze ( chords ( i ), note , chord_type , note_value ) if ( note_value ( 1 : 1 ) == \"q\" ) d = quarter_note ! quarter note if ( note_value ( 1 : 1 ) == \"h\" ) d = half_note ! half note if ( note_value ( 2 : 2 ) == \".\" ) d = dotted ( d ) ! Dotted note n = MIDI_Note ( trim ( note )) select case ( trim ( chord_type )) case ( \"m\" ) call midi % play_chord ( channel = 0 , note = n , chord = MINOR_CHORD , velocity = f_level , value = d ) case ( \"M\" ) call midi % play_chord ( channel = 0 , note = n , chord = MAJOR_CHORD , velocity = f_level , value = d ) case ( \"7\" ) call midi % play_chord ( channel = 0 , note = n , chord = DOMINANT_7TH_CHORD , velocity = f_level , value = d ) end select end do end do ! Outro: call midi % play_chord ( channel = 0 , note = n , chord = MINOR_CHORD , velocity = f_level , value = d ) call midi % end_of_track () ! (2) A track with arpeggios by plucked strings on MIDI channel 1 call midi % track_header ( track_name = \"la Folia\" ) ! Reverb: call midi % Control_Change ( channel = 1 , type = Effects_1_Depth , ctl_value = 64 ) ! Panning, slightly on the right (center is 64): call midi % Control_Change ( channel = 1 , type = Pan , ctl_value = 84 ) ! Choosing the instrument: call midi % Program_Change ( channel = 1 , instrument = Electric_Guitar_clean ) ! We repeat the theme three times but with various arpeggios: do j = 1 , 3 do i = 1 , 17 call analyze ( chords ( i ), note , chord_type , note_value ) if ( note_value ( 1 : 1 ) == \"q\" ) d = eighth_note if ( note_value ( 1 : 1 ) == \"h\" ) d = quarter_note if ( note_value ( 2 : 2 ) == \".\" ) d = dotted ( d ) n = MIDI_Note ( trim ( note )) select case ( trim ( chord_type )) case ( \"m\" ) arpeggio1 = MINOR_CHORD case ( \"M\" ) arpeggio1 = MAJOR_CHORD case ( \"7\" ) ! We don't play the fifth (7), because we want only three notes, not four: arpeggio1 = [ 0 , 4 , 10 ] end select ! Each chord is played two times, in various ways: select case ( j ) case ( 1 ) ! Swept the same way: arpeggio2 = arpeggio1 case ( 2 ) ! The second time, swept in reverse order: arpeggio2 = arpeggio1 ( 3 : 1 : - 1 ) case ( 3 ) ! Both reversed: arpeggio2 = arpeggio1 ( 3 : 1 : - 1 ) arpeggio1 = arpeggio2 end select call midi % play_broken_chord ( channel = 1 , note = n , chord = arpeggio1 , velocity = mf_level , value = d ) call midi % play_broken_chord ( channel = 1 , note = n , chord = arpeggio2 , velocity = mf_level , value = d ) end do end do call midi % end_of_track () call midi % close () print * , \"You can now play the file \" , midi % get_name () contains !> Receives a string with an encoded chords, and returns its fundamental, !> the type of chord and its encoded value subroutine analyze ( string , note , chord_type , note_value ) character ( * ), intent ( in ) :: string character ( 3 ), intent ( out ) :: note , chord_type , note_value integer :: i1 , i2 i1 = index ( trim ( string ), \" \" , back = . false .) i2 = index ( trim ( string ), \" \" , back = . true .) note = string ( 1 : i1 - 1 ) chord_type = string ( i1 + 1 : i2 - 1 ) note_value = string ( i2 + 1 :) end subroutine end program la_folia","tags":"","loc":"sourcefile/la_folia.f90.html"}]}